%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                            %
%      Projektdokumentation: Smart Shopping App                              %
%                                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt, a4paper]{report} % report ermöglicht Kapitelstruktur

% --- PRÄAMBEL: Notwendige Pakete ---
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{textcomp}

% --- SEITENLAYOUT ---
\geometry{a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}
\setlength{\headheight}{15pt}

% --- HYPERLINKS ---
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

% --- CODE-LISTING-STILE ---

% Python-Stil
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}
\lstset{style=pythonstyle}

% JSON-Stil
\lstdefinelanguage{JSON}{
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\tiny\color{codegray},
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=lines,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{blue}, % Schlüsselwörter wie true, false, null
  stringstyle=\color{codepurple},
  morestring=[b]",
  moredelim=[il][\textcolor{codegray}]{:},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
}

% --- TYPECRIPT-LISTINGS-STIL ---
\lstdefinelanguage{TypeScript}{
  keywords={
    abstract, any, as, async, await, boolean, break, byte, case, catch, char, class,
    const, continue, debugger, declare, default, delete, do, else, enum, export, extends,
    false, final, finally, for, from, function, get, if, implements, import, in, infer,
    instanceof, interface, is, keyof, let, module, namespace, never, new, null, number,
    object, of, package, private, protected, public, readonly, require, return, set,
    static, string, super, switch, symbol, this, throw, true, try, type, typeof, var,
    void, while, with, yield
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  moredelim=[il][\color{codegray}]{:},
}

\lstdefinestyle{typescriptstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=TypeScript
}

% --- KOPF- UND FUSSZEILEN ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Smart Shopping App}
\fancyhead[R]{\nouppercase{\leftmark}}
\fancyfoot[C]{\thepage}

% --- BEGINN DES DOKUMENTS ---
\begin{document}

% Titelseite
% TODO: Matrikelnummern eintragen
\begin{titlepage}
    \centering
    \vspace*{4cm}
    {\LARGE\bfseries Projektdokumentation \par}
    \vspace{1.5cm}
    {\Large \textbf{Smart Shopping App} \\[3mm]}
    \vspace{1cm}
    {\large für das Modul\\
      Programmierprojekt / Softwareentwicklungsprojekt\\}
    \vspace{1.5cm}
    {\large
      \textbf{Teammitglieder:}\\[5mm]
      David Heppenheimer (DH)\\
      Maximilian Keller (MK)\\
      Nikolas Keller (NK)\\
      Max Tremel (MT)\\
      Finn Krappitz (FK)
    }
    \vfill
    {\large \today}
\end{titlepage}

\tableofcontents
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TECHNOLOGIE-ÜBERBLICK UND ENTSCHEIDUNGSFINDUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tech Stack und Architekturentscheidungen}
\label{chap:tech_stack}

\section{Ziel der App}
Die Smart Shopping App verfolgt das Ziel, Nutzer:innen bei der Planung ihres Wocheneinkaufs möglichst kosteneffizient zu unterstützen. Anhand einer individuell erstellten Einkaufsliste werden sowohl reguläre Grundpreise als auch zeitlich begrenzte Angebots­preise aus digitalen Prospekten berücksichtigt, um für den gesamten Warenkorb den günstigsten Supermarkt zu ermitteln. Dieses ambitionierte Vorhaben erfordert eine sorgfältige Auswahl und Kombination von Frontend-Technologien, Backend-Architektur, Datenbanklösungen, Authentifizierungsdiensten sowie einer robusten Data-Engineering-Pipeline.

\section{Überblick über den Technologie-Stack}
Um den hohen Anforderungen an Performance, Wartbarkeit, Skalierbarkeit und Entwicklungsgeschwindigkeit gerecht zu werden, haben wir unseren Tech Stack in fünf Hauptkomponenten gegliedert: das mobile Frontend, die Backend-API, die relationale Datenbank, den Authentifizierungsdienst und die Data-Engineering-Schicht für das Web Scraping.

\section{Frontend}
\subsection{Technologien: Expo Go, React Native und NativeWind}
Für das mobile Frontend setzen wir auf Expo Go in Kombination mit React Native. Diese Wahl erlaubt es, mit nur einer Codebasis Applikationen für iOS und Android zu realisieren, was Entwicklungs- und Testaufwände deutlich reduziert. Durch Expo Go entfällt der aufwendige Build-Prozess nativer Apps: Änderungen am UI werden direkt auf realen Geräten oder in Simulatoren sichtbar, was die Iterationszyklen verkürzt und eine enge Feedback-Schleife ermöglicht.

Als Styling-System dient NativeWind, eine Tailwind-CSS-Adaption für React Native. Mit Utility-Klassen lassen sich konsistente Designs ohne umfangreiche Stylesheets implementieren, was den Boilerplate-Aufwand minimiert und die Wartbarkeit steigert.

\subsection{Alternative Ansätze}
Alternativ zum React-Native-Ansatz standen Frameworks wie Flutter oder Web-View-basierte Lösungen (Ionic/Cordova) zur Debatte. Flutter glänzt mit hoher Rendering-Performance und einem reichhaltigen Widget-Ökosystem, erfordert jedoch den Einsatz von Dart und eine neue Lernkurve für das Team. Ionic und Cordova ermöglichen schnellen Einstieg über HTML/CSS in einer Web-View, sind aber in puncto nativer Performance und Hardware-Integration limitiert. Die Entscheidung fiel schließlich auf Expo/React Native, da wir auf JavaScript/TypeScript-Kompetenz im Team aufbauen und den Vorteil der breiten Community nutzen wollten.

\section{Backend}
\subsection{Technologieauswahl: Node.js mit Express}
Als Backend-API kommt Node.js mit dem minimalistischen Framework Express zum Einsatz. Express bietet eine schlanke, unopinionated Basis für den Aufbau von REST-Endpunkten und lässt sich durch Middleware flexibel erweitern. In Verbindung mit TypeScript erreichen wir durch typgesicherte Routen und Datenmodelle bereits zur Entwicklungszeit eine hohe Fehlerfrüherkennung.

\subsection{Datenbankzugriffe mit Prisma}
Für die Datenbankzugriffe verwenden wir Prisma als ORM. Prisma ermöglicht es, Datenbankschemata deklarativ in einer schema.prisma-Datei zu definieren und mit Migrationsskripten (prisma migrate) versioniert auszurollen. Die generierten TypeScript-Clients bieten eine typgesicherte API für alle CRUD-Operationen und fangen schon zur Kompilierzeit viele Fehler ab.

Ein typisches Beispiel für die Definition eines Prisma-Modells in der Schema-Datei sieht wie folgt aus:

\begin{lstlisting}[language=TypeScript,caption={Schema-Definition mit Prisma}]
model Product {
id        Int      @id @default(autoincrement())
name      String
price     Float
store     String
createdAt DateTime @default(now())
}
\end{lstlisting}

Nach dem Befehl npx prisma migrate dev --name init wird die Migration eingespielt und der Prisma Client generiert. Im Code kann man den Client dann wie im folgenden Beispiel verwenden:

\begin{lstlisting}[style=typescriptstyle,caption={Beispielhafte Verwendung des Prisma Client}]
    import { PrismaClient } from "@prisma/client";
    import express from "express";
    
    const prisma = new PrismaClient();
    const app = express();
    
    app.use(express.json());
    
    app.post('/products', async (req, res) => {
      const { name, price, store } = req.body;
      try {
        const newProduct = await prisma.product.create({
          data: { name, price, store },
        });
        console.log("Created product:", newProduct);
        res.status(201).json(newProduct);
      } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Fehler beim Anlegen des Produkts.' });
      }
    });
    
    app.listen(3000, () => {
      console.log("Server laeuft auf Port 3000");
    });
    \end{lstlisting}

\subsection{Authentifizierung mit Clerk}
Zur Authentifizierung und zum User-Management setzen wir Clerk ein. Clerk ist eine Identity‑as‑a‑Service‑Plattform, die vollständig vorkonfigurierte Anmelde‑ und Registrierungsflüsse sowie Passwort‑Zurücksetzen‑Funktionalitäten bereitstellt. Zusätzlich unterstützt Clerk Social‑Login‑Anbieter wie Google, Facebook und Apple und ermöglicht Single‑Sign‑On (SSO) für nahtlose Benutzererlebnisse. Multi‑Faktor‑Authentifizierung (MFA) inklusive E‑Mail‑ und SMS‑Verifizierung ist standardmäßig integriert, ebenso wie Features wie Brute‑Force‑Schutz, automatisches Session‑Timeout und Token‑Revokation.

Mittels der offiziellen React- und React Native SDKs können wir Clerk‑UI-Komponenten direkt in unsere Expo App integrieren, Benutzerattribute verwalten und Zugriffsrechte über Claims abbilden. Clerk übernimmt das komplette Session‑Management sowie die sichere Speicherung von Benutzerdaten nach GDPR‑Standards, wodurch wir erheblichen Entwicklungs- und Wartungs­aufwand für eigene Authentifizierungslösungen einsparen und gleichzeitig hohe Sicherheits- und Compliance-Vorgaben erfüllen.

\subsection{Alternativen zum Backend-Stack}
Im Vergleich dazu hätten wir auch auf umfassendere Frameworks wie NestJS setzen können, das mit Dependency Injection und Modulen ein höheres Maß an Struktur und Konventionen bietet. Allerdings bringt NestJS eine steilere Lernkurve und mehr Boilerplate mit sich. Auch Python-Frameworks wie Django oder Flask waren im Gespräch: Django punktet mit einem integrierten Admin-Interface, erfordert aber eine zusätzliche Sprache im Projekt.

\section{Datenbank}
\subsection{Wahl von PostgreSQL}
Für die persistente Speicherung nutzen wir PostgreSQL. Neben bewährter ACID-Konformität und Transaktions­sicherheit profitieren wir von leistungsfähigen Features wie JSONB-Feldern für flexible Metadaten und komplexen Abfragen. Die umfangreichen Backup- und Replikations­mechanismen stellen den langfristigen Betrieb unter wachsendem Datenaufkommen sicher.

\subsection{Alternative Datenbanken}
Als Alternative standen relationale Systeme wie MySQL/MariaDB oder NoSQL-Datenbanken wie MongoDB zur Auswahl. MySQL bietet ähnliche Stabilität, ist jedoch in JSON-Operationen etwas eingeschränkter. MongoDB punktet mit schemaloser Flexibilität, macht aber konsistente Joins und Transaktions­szenarien deutlich aufwendiger.

\section{Data-Engineering und Web Scraping}
\subsection{Technologiewahl und Vorgehen}
Die Preis- und Angebotsdaten erfassen wir mit Python: Selenium steuert einen echten Browser, um dynamisch nachgeladene Inhalte zuverlässig zu extrahieren, und BeautifulSoup übernimmt das strukturierte Parsen des resultierenden HTML. Ein klar getrenntes Zwei-Stufen-Konzept – ein Basisscraping für Name, Preis und Detail-URLs, gefolgt von einem Enrichment-Durchlauf für Marken-, Verpackungs- und Bildinformationen – sorgt für Modularität und Fehlertoleranz. Beide Schritte nutzen concurrent.futures.ThreadPoolExecutor zur Parallelisierung, um Laufzeiten zu minimieren. In den folgenden Kapiteln gehen wir detailliert auf die einzelnen Scraping- und Enrichment-Prozesse ein.

\section{Zusammenfassung}
Die gewählte Architektur aus Expo/React Native, Express/Prisma/Clerk, PostgreSQL und Python-Scraping schafft eine ausgewogene Balance zwischen schneller Frontend-Entwicklung, typgesicherter Backend-Logik, sicherer Authentifizierung, zuverlässiger Datenhaltung und robustem Data-Engineering. Diese Basis ermöglicht es, die folgenden Kapitel – von Web Scraping über API-Design bis zur UI-Implementierung – konsistent und zielführend weiterzuführen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SCRAPER-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Web Scraping zur Erfassung von Produktdaten}
\label{chap:web_scraping}

\section{Einleitung, ursprünglicher Umfang und finale Problemstellung}
Die Grundlage für dieses Projekt bildete die Notwendigkeit, umfassende und aktuelle Produktdaten von deutschen Supermarktketten zu akquirieren. Hierbei wurde eine strategische Trennung vorgenommen: Die in diesem Kapitel beschriebenen Scraper konzentrieren sich auf die Erfassung der regulären \textbf{Grundpreise} direkt von den Webseiten der Einzelhändler. Parallel dazu wird die Erfassung von zeitlich begrenzten \textbf{Angebotspreisen} über einen separaten Scraper realisiert, der die Daten der Prospekt-Plattform \textit{Marktguru} für eine breitere Auswahl an Märkten ausliest. Die technische Umsetzung dieses Angebot-Scrapers wird in einem gesonderten Kapitel behandelt.

Der anfängliche Anspruch für das hier dokumentierte Grundpreis-Scraping war äußerst ambitioniert: Es sollten die Sortimente einer breiten Palette von Einzelhändlern erfasst werden, darunter \textbf{REWE, EDEKA, Lidl, Kaufland, Marktkauf, tegut, Norma, Aldi Nord} und \textbf{Aldi Süd}.

Eine erste Sondierungsphase offenbarte jedoch schnell erhebliche technische und strukturelle Hürden. Viele der untersuchten Webseiten implementieren hochentwickelte Schutzmechanismen gegen automatisierte Datenabfragen, weisen extrem komplexe und inkonsistente Seitenstrukturen auf oder bieten kein vollständiges Online-Produktsortiment, das für ein systematisches Scraping zugänglich wäre.

Angesichts dieser Herausforderungen wurde eine strategische Entscheidung getroffen: Der Fokus des Projekts wurde auf jene Anbieter reduziert, bei denen eine zuverlässige und wiederholbare Datenerfassung im gegebenen Zeitrahmen realisierbar erschien. Letztendlich konzentrierte sich die Entwicklungsarbeit erfolgreich auf die Webauftritte von \textbf{Aldi Nord}, \textbf{Aldi Süd} und \textbf{Netto}.

Die zentrale technische Herausforderung bei diesen Zieldomänen bestand darin, dass moderne Webseiten Inhalte nicht mehr als statische HTML-Dokumente ausliefern. Stattdessen werden Produktlisten dynamisch mittels JavaScript nachgeladen. Dies erforderte eine sorgfältige Analyse der verbleibenden Webseitenstrukturen und die Auswahl einer robusten Technologie, die in der Lage ist, eine reale Benutzerinteraktion zu simulieren, um die vollständigen und korrekten Daten zu extrahieren.

\section{Technologie-Evaluierung und strategische Entscheidung}
\subsection{Erster Ansatz: Requests und BeautifulSoup}
Der initiale Plan sah vor, die Daten mit einer Kombination der Python-Bibliotheken \texttt{requests} und \texttt{BeautifulSoup} zu extrahieren. Dieser Ansatz scheiterte jedoch schnell aus zwei Hauptgründen:
\begin{enumerate}
    \item \textbf{Dynamisches Laden von Inhalten:} Bei der Analyse des von \texttt{requests} abgerufenen HTML-Codes wurde festgestellt, dass die Produktlisten fehlten. Die Webseiten laden die Produkte erst nach dem initialen Laden der Seite über JavaScript-APIs nach. \texttt{requests} führt kein JavaScript aus und erhält somit nur das initiale, unvollständige HTML-Dokument.
    \item \textbf{Bot-Erkennung:} Webseiten nutzen verschiedene Techniken, um automatisierte Skripte zu erkennen. Dazu gehören die Analyse des \texttt{User-Agent}-Headers oder die Überprüfung von Verhaltensmustern. Obwohl Header manuell gesetzt werden können, sind diese einfachen Maßnahmen oft nicht ausreichend.
\end{enumerate}

\subsection{Die Lösung: Selenium WebDriver}
Aufgrund der Unzulänglichkeiten des ersten Ansatzes fiel die Wahl auf \textbf{Selenium}. Selenium ist ein Framework zur Automatisierung von Webbrowsern, das eine echte Browser-Instanz (z.B. Google Chrome) steuert.

Dies bietet entscheidende Vorteile:
\begin{itemize}
    \item \textbf{Vollständiges Rendern der Seite:} Da ein echter Browser verwendet wird, wird sämtliches JavaScript ausgeführt. Dynamisch nachgeladene Inhalte sind somit im gerenderten HTML-DOM vorhanden und können extrahiert werden.
    \item \textbf{Simulation von Benutzerinteraktionen:} Selenium kann Aktionen wie das Scrollen der Seite oder das Klicken auf "Mehr anzeigen"-Buttons simulieren, um alle Produkte sichtbar zu machen.
    \item \textbf{Umgehung von Bot-Erkennung:} Durch die Steuerung eines echten Browsers erscheint die Interaktion für den Server weitaus menschlicher. Zusätzlich wurden in den Skripten Konfigurationen vorgenommen, um die Automatisierung weiter zu verschleiern.
\end{itemize}
Die Kombination aus Selenium zum Laden der Seite und BeautifulSoup zum Parsen des resultierenden HTML-Codes (\texttt{driver.page\_source}) erwies sich als die robusteste und erfolgreichste Methode.

\section{Implementierungsdetails: Ein zweistufiger Prozess}
\label{sec:scraping_prozess}
Im Verlauf der Entwicklung kristallisierte sich heraus, dass ein monolithischer Ansatz, bei dem alle Daten in einem einzigen Durchgang erfasst werden, ineffizient und fehleranfällig ist. Daher wurde ein robusterer, zweistufiger Prozess implementiert, bestehend aus einem initialen \textbf{Scraping}-Lauf und einem nachgelagerten \textbf{Anreicherungs}-(Enrichment)-Lauf.

\subsection{Strategische Trennung der Prozessschritte}
Der ursprüngliche Plan sah vor, dass der Scraper eine Kategorieseite lädt, die Links zu allen Produkten extrahiert und dann sofort jede dieser Produkt-Detailseiten einzeln aufruft, um sämtliche Informationen zu sammeln. Dieser Ansatz wurde verworfen, da er die Gesamtlaufzeit massiv erhöht und die Fehlerbehandlung verkompliziert hätte. Die Trennung brachte entscheidende Vorteile wie Robustheit, Effizienz und Modularität.

\subsection{Stufe 1: Der Scraping-Prozess}
In der ersten Stufe konzentrieren sich die Scraper-Skripte (z.B. \texttt{aldi\_sued\_scraper.py}) darauf, schnell die wesentlichen Basisdaten von den Kategorieseiten zu sammeln. Nach einer verworfenen Idee der vollständigen Automatisierung wurde entschieden, die URLs der Kategorieseiten \textbf{manuell zu pflegen}, um die Zuverlässigkeit zu erhöhen.

Der Ablauf für jede URL ist wie folgt:
\begin{enumerate}
    \item \textbf{Browser-Initialisierung und Seitenaufruf:} Starten einer konfigurierten Selenium-WebDriver-Instanz und Navigation zur Ziel-URL.
    \item \textbf{Interaktion:} Akzeptieren von Cookie-Bannern und Ausführen von Aktionen wie Scrollen und Klicken auf "Mehr anzeigen"-Buttons, um alle Produkte zu laden.
    \item \textbf{Basis-Datenextraktion:} Übergabe des Seitenquelltextes an BeautifulSoup und Extraktion der Kerninformationen: \textbf{Name, Preis} und die \textbf{URL zur Produkt-Detailseite}.
\end{enumerate}
Das Ergebnis dieses ersten Schrittes ist eine JSON-Datei (z.B. \texttt{aldi\_sued\_products\_latest.json}), die eine Liste von Produkten mit diesen rohen Basis-Informationen enthält.

\subsection{Stufe 2: Der Anreicherungsprozess (Enrichment)}
In der zweiten Stufe kommen die Enricher-Skripte (z.B. \texttt{aldi\_nord\_enricher.py}) zum Einsatz. Sie lesen die vom Scraper erstellte JSON-Datei ein und veredeln die Daten, indem sie jede Produkt-URL aufrufen und Detailinformationen extrahieren.

Der Enricher erledigt folgende Aufgaben:
\begin{enumerate}
    \item \textbf{Aufruf der Produkt-URL:} Für jedes Produkt wird die Detailseiten-URL aufgerufen, meist mit der schnelleren `requests`-Bibliothek, da diese Seiten oft statischer sind.
    \item \textbf{Extraktion von Detailinformationen:} Von der Produktseite werden zusätzliche Daten gesammelt:
        \begin{itemize}
            \item \textbf{Markenname}
            \item \textbf{Hochauflösende Bild-URL}
            \item \textbf{Detaillierte Grundpreis-Angaben} und Verpackungsbeschreibungen
        \end{itemize}
    \item \textbf{Aktualisierung und Speicherung:} Die neuen Informationen werden dem bestehenden Datensatz hinzugefügt und in einer neuen, angereicherten JSON-Datei (z.B. \texttt{aldi\_nord\_products\_enriched\_latest.json}) gespeichert.
\end{enumerate}

\section{Performance-Optimierung durch Parallelisierung}
\label{sec:scraping_performance}
Ein Hauptproblem war die lange Ausführungszeit. Die Lösung war die Implementierung von paralleler Ausführung in \textbf{beiden Prozessschritten} mithilfe des \texttt{concurrent.futures.ThreadPoolExecutor} aus der Python-Standardbibliothek.

Anstatt die URLs sequenziell abzuarbeiten, wird ein "Pool" von Worker-Threads erstellt. Jeder Thread erhält eine URL und führt den Scraping- bzw. Anreicherungsprozess unabhängig und gleichzeitig zu den anderen Threads aus.

\begin{lstlisting}[language=Python, caption={Parallele Ausführung mit ThreadPoolExecutor}]
max_workers = min(20, len(URLS))
with ThreadPoolExecutor(max_workers=max_workers) as executor:
    # Starte die Scraping- oder Enriching-Aufgaben
    future_to_url = {executor.submit(process_url_function, url): url for url in URLS}
    
    for future in as_completed(future_to_url):
        url = future_to_url[future]
        try:
            result = future.result()
            # Ergebnisse verarbeiten...
        except Exception as exc:
            logger.error(f"URL {url} hat eine Ausnahme erzeugt: {exc}")
\end{lstlisting}
Durch diese Parallelisierung konnte die Gesamtdauer für die Datenerfassung von mehreren Stunden auf einen Bruchteil dieser Zeit reduziert werden.

\section{Datenspeicherung und finale Datenstruktur}
\label{sec:scraping_datenspeicherung}
Die extrahierten und bereinigten Produktdaten werden im \textbf{JSON-Format} gespeichert. Der zweistufige Prozess spiegelt sich auch in der Dateibenennung wider:
\begin{enumerate}
    \item \textbf{Scraper-Output:} Der erste Schritt erzeugt eine Datei wie \texttt{\ldots\_products\_latest.json}.
    \item \textbf{Enricher-Output:} Der zweite Schritt liest diese Datei ein und erzeugt eine angereicherte Zieldatei, z.B. \texttt{\ldots\_products\_enriched\_latest.json}.
\end{enumerate}

Für jeden Lauf wird eine neue JSON-Datei mit einem Zeitstempel im Dateinamen erstellt. Zusätzlich wird eine Datei mit dem Suffix \texttt{\_latest.json} erzeugt oder aktualisiert, die immer die Daten des letzten erfolgreichen Laufs enthält. Dies erleichtert den Zugriff für nachfolgende Prozessschritte.

Die Struktur der finalen, angereicherten JSON-Datei ist wie folgt aufgebaut:
\begin{lstlisting}[language=JSON, caption={Beispielhafte JSON-Struktur der finalen Ausgabedatei}]
{
  "metadata": {
    "source": "aldi_sued",
    "scraped_at": "2025-07-20 15:43:00",
    "total_products": 458
  },
  "products": [
    {
      "store": "aldi_sued",
      "name": "Bio Eier",
      "price": 3.29,
      "brand": "GUT BIO",
      "unit": "Stueck",
      "size": "10",
      "url": "https://www.aldi-sued.de/p/...",
      "image_url": "https://..."
    },
    {
      "store": "aldi_sued",
      "name": "Nutella",
      "price": 4.99,
      "brand": "Ferrero",
      "unit": "g",
      "size": "750",
      "url": "https://...",
      "image_url": "https://..."
    }
  ]
}
\end{lstlisting}
Diese strukturierte Ausgabe bildet die saubere und zuverlässige Datenbasis für alle weiteren Analysen und Verarbeitungsschritte im Projekt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UI-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Benutzeroberfläche (UI)}
\label{chap:ui}

\section{Einleitung}
Die Benutzeroberfläche stellt die Verbindung zwischen Nutzer:innen und den technischen Funktionalitäten der Smart Shopping App her. Sie spielt eine zentrale Rolle bei der täglichen Nutzung der App, da sie das Hinzufügen von Produkten zur Einkaufsliste, das Anzeigen und Bearbeiten der Listen sowie die Darstellung der Preisinformationen und Marktvergleiche ermöglicht.

\section{Grundlegende Anforderungen an die UI}
Die Benutzeroberfläche der Smart Shopping App muss verschiedene grundlegende Anforderungen erfüllen, um eine optimale Nutzererfahrung zu gewährleisten. Eine intuitive Bedienbarkeit steht dabei im Vordergrund, sodass die Navigation und Bedienung der App für alle Nutzer:innen verständlich und schnell erlernbar ist. Das responsive Design stellt sicher, dass sich die Oberfläche an unterschiedliche Bildschirmgrößen anpasst, sei es auf Smartphones, Tablets oder Desktop-Geräten.

Ein weiterer wichtiger Aspekt ist das Echtzeit-Feedback, durch das Preisvergleiche und Marktvorschläge unmittelbar nach Eingabe oder Änderung der Einkaufsliste angezeigt werden. Die modulare Architektur der UI ermöglicht es, die Anwendung um weitere Features wie zusätzliche Märkte oder Angebotsfunktionen zu erweitern, ohne die bestehende Struktur grundlegend ändern zu müssen.

\section{Mockups und zentrale Ansichten}
% Hier können später Skizzen/Mobile Screenshots oder Diagramme eingefügt werden.
% Beispiel (mit Platzhalter):
\begin{figure}[h!]
    \centering
    \fbox{
        \parbox{0.85\textwidth}{
            \vspace{3cm}
            \begin{center}
                \textbf{Abb. 1: Mockup Startansicht der App}\\
                \emph{(Platzhalter für spätere Screenshots oder Entwürfe)}
            \end{center}
            \vspace{3cm}
        }
    }
    \caption{Mockup: Hauptansicht der Smart Shopping App}
    \label{fig:ui_mockup}
\end{figure}

\section{Beschreibung zentraler UI-Elemente}
Die Benutzeroberfläche der Smart Shopping App besteht aus mehreren zentralen Elementen, die eine optimale Nutzererfahrung gewährleisten. Die Einkaufsliste bietet eine übersichtliche Darstellung der gewählten Produkte und ermöglicht es den Nutzer:innen, Mengen anzupassen und gekaufte Artikel abzuhaken. Die Marktvergleichsübersicht zeigt transparent an, bei welchem Markt die aktuelle Liste am günstigsten ist, und bietet eine detaillierte Übersicht über die Einzelpreise der Produkte.

Ein weiteres wichtiges Element ist die Produktsuche mit Autocomplete-Funktion, die das Hinzufügen neuer Produkte durch intelligente Vorschläge erheblich beschleunigt. Die Detailsicht stellt zusätzliche Produktinformationen zur Verfügung, einschließlich der durch Scraping und Enrichment gewonnenen Daten sowie aktueller Angebotspreise. Schließlich ermöglicht der Bereich für Nutzerprofil und Einstellungen die Personalisierung der App durch die Auswahl bevorzugter Märkte und verschiedener Filteroptionen.

\section{Geplante Weiterentwicklungen}
% Hier können noch weitere Features oder Ideen wie Barcode-Scanner, ortsbasierte Marktempfehlungen etc. ergänzt werden.

\section{Home-Screen}
\label{sec:home_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Home-Screen dient als zentrale Übersicht für die Einkaufsliste des Nutzers und stellt den wichtigsten Interaktionspunkt der Anwendung dar. Hier kann der Nutzer seine aktuelle Einkaufsliste einsehen und einzelne Produkte aus der Liste entfernen. Darüber hinaus besteht die Möglichkeit, die gesamte Liste zu archivieren oder eine neue Einkaufsliste anzulegen, falls noch keine existiert. Der Screen zeigt außerdem den Gesamtpreis der Liste an und ermöglicht den direkten Wechsel zur Detailansicht der Liste.

\subsubsection{UI/UX-Beschreibung}

\textbf{Wichtige UI-Elemente:}
\begin{itemize}
    \item \textbf{TopBar:} Navigationsleiste am oberen Rand
    \item \textbf{ScrollView:} Zeigt die Einkaufsliste als scrollbare Kartenansicht
    \item \textbf{Card-Komponenten:} Jede Karte repräsentiert ein Produkt mit Name, Marke, Menge, Preis, Bild und Lösch-Button
    \item \textbf{ButtonSquare:} Button zum Wechsel in die Detailansicht der Liste
    \item \textbf{Floating View:} Zeigt den Gesamtpreis der Liste an
    \item \textbf{"Create Shopping List"-Button:} Erscheint, wenn noch keine Liste existiert
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
Die Benutzerinteraktion erfolgt über verschiedene gut erreichbare Elemente. Produkte können über den Lösch-Button auf jeder Produktkarte entfernt werden, während die gesamte Einkaufsliste über einen entsprechenden Button archiviert werden kann. Das Anlegen neuer Listen erfolgt über den "Create Shopping List"-Button, und der Wechsel zur Detailansicht ist über den Button mit Einkaufswagen-Icon möglich.

\subsubsection{User Flow}

\textbf{Von welchem Screen kommt der Nutzer hierher?}
Der Nutzer gelangt meistens über die Tab-Navigation als Startscreen oder nach dem Login auf den Home-Screen.

\noindent\textbf{Wohin geht es von hier aus?}
Vom Home-Screen aus stehen dem Nutzer verschiedene Navigationsmöglichkeiten zur Verfügung. Er kann zur Detailansicht der Einkaufsliste wechseln, indem er die entsprechende Option auswählt. Darüber hinaus besteht die Möglichkeit, zu Produktdetails zu navigieren, sofern diese Funktionalität über die Produktkarten implementiert ist. Weitere Optionen umfassen das Archivieren der aktuellen Liste oder das Anlegen einer neuen Liste.

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Komponenten:}
\begin{itemize}
    \item ListScreen (Hauptkomponente)
    \item TopBar (Navigationsleiste)
    \item Card (Produktkarte)
    \item ButtonSquare (Floating Action Button)
    \item LoadingSpinner (Ladeanzeige)
\end{itemize}

\noindent\textbf{State Management:}
\begin{itemize}
    \item React State (useState, useEffect, useCallback)
    \item Kontext: useProductContext für Produktdaten und Ladezustand
\end{itemize}

\noindent\textbf{Services/APIs:}
Die Kommunikation mit dem Backend erfolgt über den api-Service, der alle Backend-Requests abwickelt. Dieser umfasst Funktionen wie getShoppingListItems zum Abrufen der Listenelemente, createShoppingList zum Erstellen neuer Listen, deleteFromShoppingList zum Entfernen von Produkten und archiveShoppingList zum Archivieren von Listen.

\subsubsection{Wichtige Funktionen/Methoden}
\begin{itemize}
    \item \textbf{loadList:} Lädt die aktuelle Einkaufsliste und prüft, ob eine existiert.
    \item \textbf{handleCreateShoppingList:} Erstellt eine neue Einkaufsliste via API.
    \item \textbf{handleDelete:} Löscht ein Produkt aus der Liste.
    \item \textbf{handleArchiveList:} Archiviert die aktuelle Liste.
    \item \textbf{calculateTotal:} Berechnet den Gesamtpreis der Einkaufsliste.
    \item \textbf{Scroll-Handling:} Zeigt/Versteckt Floating Buttons je nach Scrollposition (Performance-Optimierung mit react-native-reanimated).
\end{itemize}

\subsubsection{Besondere Herausforderungen}
Bei der Entwicklung des Home-Screens entstanden verschiedene technische Herausforderungen, die spezielle Lösungsansätze erforderten. Die Performance-Optimierung wurde durch den Einsatz von Reanimated für die Animation der Floating Buttons erreicht, um ein flüssiges Benutzererlebnis zu gewährleisten. Eine umfangreiche Fehlerbehandlung mit Alerts und Fallbacks stellt sicher, dass die Anwendung auch bei fehlgeschlagenen API-Requests stabil funktioniert.

Ein besonderer Fokus lag auf der User Experience, wobei unterschiedliche UI-Zustände wie das Fehlen einer Liste, eine leere Liste oder eine gefüllte Liste klar unterschieden und dem Nutzer verständlich kommuniziert werden. Die Synchronisation der Daten wird durch das automatische Neuladen der Liste bei jedem Fokus auf den Screen mittels useFocusEffect gewährleistet, sodass immer die aktuellsten Daten angezeigt werden.

\section{Explore-Screen}
\label{sec:explore_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Explore-Screen dient dazu, dem Nutzer eine strukturierte Übersicht über Produktkategorien und verfügbare Supermärkte zu bieten. Dieser Screen ermöglicht es dem Nutzer, gezielt nach Produkten zu suchen, verschiedene Kategorien zu durchstöbern oder Angebote von bestimmten Märkten anzeigen zu lassen. Dadurch wird eine intuitive Navigation durch das gesamte Produktsortiment der App gewährleistet.

\subsubsection{UI/UX-Beschreibung}

\textbf{Zentrale Elemente:}
\begin{itemize}
    \item Oben befindet sich eine Navigationsleiste (TopBar).
    \item Ein prominenter Button ('Add Products') ermöglicht die Produktsuche.
    \item Darunter werden die Lieblingskategorien ('Your Favourites') angezeigt.
    \item Es folgt eine Liste von Kategorien (z.B. Gemüse, Obst, Milch).
    \item Am unteren Ende werden verfügbare Stores (Supermärkte) als auswählbare Felder angezeigt, farblich hervorgehoben je nach Markt.
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
Die Benutzerinteraktion erfolgt über zwei Hauptkategorien von Elementen. Der 'Add Products'-Button öffnet die Produktsuche und ermöglicht den direkten Einstieg in die Produktauswahl. Zusätzlich sind sowohl Kategorien als auch Stores als anklickbare Elemente gestaltet, die zu einer gefilterten Produktsuche führen und dem Nutzer eine zielgerichtete Navigation ermöglichen.

\subsubsection{User Flow}

\textbf{Einstieg:} Der Nutzer gelangt meist von einem Tab-Menü oder der Hauptnavigation auf diesen Screen.

\noindent\textbf{Von hier aus kann der Nutzer:}
Der Explore-Screen bietet verschiedene Navigationsmöglichkeiten für den Nutzer. Über den "Add Products"-Button kann er direkt zur Produktsuche navigieren und mit der Zusammenstellung seiner Einkaufsliste beginnen. Alternativ kann er über eine Kategorie oder einen Store gezielt Produkte filtern und anzeigen lassen, um spezifische Angebote zu finden. Nach der Auswahl wird der Nutzer zur Such- oder Produktübersicht weitergeleitet, wo er seine Auswahl verfeinern kann.

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Hauptkomponente:} explore (React Functional Component)

\noindent\textbf{Eingesetzte Komponenten:}
\begin{itemize}
    \item TopBar (Navigation)
    \item SearchButton (Produktsuche)
    \item CategorieField (Favoriten)
    \item CategorieGroup (Kategorien \& Stores)
\end{itemize}

\noindent\textbf{Datenmodell:} Store-Typ aus den globalen Typen

\noindent\textbf{API:} Daten werden über api.getStores() geladen

\noindent\textbf{State Management:} React useState/useEffect (lokaler State)

\subsubsection{Wichtige Funktionen/Methoden}

\begin{itemize}
    \item \textbf{getStoreColor(name: string):} Weist jedem Store eine spezifische Farbe zu.
    \item \textbf{useEffect + fetchStores:} Lädt beim ersten Rendern die Store-Liste asynchron von der API und speichert sie im State.
    \item \textbf{Interaktive Elemente (onPress):} Navigieren mit router.push zur Suchseite, ggf. mit Store-Filter.
\end{itemize}

\subsubsection{Besondere Herausforderungen}
Die Entwicklung des Explore-Screens brachte verschiedene technische Herausforderungen mit sich. Das dynamische Laden und Anzeigen der Stores mit individueller Farbcodierung erforderte eine flexible Architektur, die eine einheitliche Darstellung bei unterschiedlichen Datenquellen gewährleistet. Eine robuste Fehlerbehandlung beim Laden der Stores wurde implementiert, die dem Nutzer mittels Alert-Nachrichten bei Problemen entsprechendes Feedback gibt. Zusätzlich stellte die Gestaltung einer übersichtlichen und intuitiven Benutzeroberfläche trotz der vielen Auswahlmöglichkeiten eine besondere Herausforderung dar, die durch eine durchdachte Kategorisierung und visuelle Hierarchie gelöst wurde.

\section{Search-Screen}
\label{sec:search_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Search-Screen ermöglicht es dem Nutzer, gezielt nach Produkten zu suchen, verschiedene Filter anzuwenden und gefundene Produkte zur Einkaufsliste hinzuzufügen. Das Hauptziel besteht darin, eine schnelle und komfortable Möglichkeit zu bieten, passende Angebote zu finden und die Produktauswahl durch Filter für Kategorie und Store zu verfeinern. Dieser Screen stellt somit das Herzstück der Produktsuche und -auswahl dar.

\subsubsection{UI/UX-Beschreibung}

\textbf{Zentrale Elemente:}
\begin{itemize}
    \item \textbf{Suchleiste:} Oben mittig, ermöglicht die Suche nach Produktnamen oder Marken.
    \item \textbf{Filter-Button:} Links neben der Suchleiste öffnet ein Modal für Filteroptionen (Kategorie, Store).
    \item \textbf{Cancel-Button:} Rechts neben der Suchleiste, löscht die aktuelle Suche.
    \item \textbf{Produktliste:} Zeigt gefilterte oder alle Produkte als Karten an, sortiert nach günstigstem Preis.
    \item \textbf{Produktkarte:} Enthält Produktdetails und einen Button (PlusCircle), um das Produkt zur Einkaufsliste hinzuzufügen.
    \item \textbf{Filter-Modal:} Ermöglicht Mehrfachauswahl von Kategorien und Stores, sowie das Zurücksetzen oder Anwenden der Filter.
    \item \textbf{Ladespinner:} Wird angezeigt, solange die Produktdaten geladen werden.
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
Der Search-Screen bietet dem Nutzer verschiedene Interaktionsmöglichkeiten für eine effiziente Produktsuche. Die Suchleiste als Textinput ermöglicht die direkte Eingabe von Suchbegriffen, während der Filter-Button ein Modal mit erweiterten Filteroptionen öffnet. Ein Cancel-Button setzt die aktuelle Suche zurück und ermöglicht einen Neustart. Die Produktkarten sind klickbar und führen zur Detailansicht der jeweiligen Artikel. Der PlusCircle-Button auf jeder Karte fügt das entsprechende Produkt direkt zur Einkaufsliste hinzu. Das Filter-Modal selbst enthält MultiSelects für die Auswahl sowie Reset- und Apply-Buttons für die Filterverwaltung.

\subsubsection{User Flow}
\textbf{Einstieg:} Der Nutzer gelangt meist von einem Tab oder durch Auswahl eines Stores auf den Search-Screen.

\noindent\textbf{Aktionen:} Auf diesem Screen kann der Nutzer verschiedene Aktionen durchführen, um seine Produktsuche zu optimieren. Er kann gezielt nach Produkten suchen, verschiedene Filter anwenden, gefundene Produkte direkt zur Einkaufsliste hinzufügen oder detaillierte Produktinformationen aufrufen.

\noindent\textbf{Navigation:}
Die Navigation vom Search-Screen aus bietet verschiedene Möglichkeiten. Ein Klick auf ein Produkt führt zur Detailansicht, während das Anwenden von Filtern eine aktualisierte Produktliste zur Verfügung stellt. Darüber hinaus ist die Rückkehr zu anderen Tabs oder Screens jederzeit möglich, um einen flexiblen Workflow zu gewährleisten.

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Hauptkomponente:} SearchSite (funktionale React-Komponente)

\noindent\textbf{Verwendete Komponenten:}
\begin{itemize}
    \item SearchBar (benutzerdefinierte Suchleiste)
    \item CustomMultiSelect (Filterauswahl)
    \item SearchCard (Produktkarte)
    \item ButtonSizeable, ButtonTransparent (Buttons)
    \item LoadingSpinner (Ladesymbol)
\end{itemize}

\noindent\textbf{State Management:} React Context (useProductContext) für Produkte und Laden-Status

\noindent\textbf{API:} Zugriff auf Stores und Produkte über api-Service

\subsubsection{Abhängigkeiten}

\textbf{Services:} api (z.B. getStores, addToShoppingList)

\noindent\textbf{State:} Produkte, Stores, Filterauswahl, Suchbegriff, Ladezustand

\noindent\textbf{Libraries:} expo-router, @shopify/flash-list, lucide-react-native (Icons), React Native Komponenten

\subsubsection{Wichtige Funktionen/Methoden}
\begin{itemize}
    \item \textbf{handleSearch(query):} Filtert Produkte nach Suchbegriff und sortiert nach Preis.
    \item \textbf{applyFilters():} Wendet Suchbegriff, Kategorie- und Store-Filter an, sortiert Ergebnis.
    \item \textbf{fetchStores():} Holt Store-Daten von der API.
    \item \textbf{useEffect-Hooks:}
    \begin{itemize}
        \item Lädt Stores beim Mounten.
        \item Setzt Store-Filter, wenn ein Store-Name als Parameter übergeben wird.
        \item Lädt Produkte, falls noch nicht vorhanden.
        \item Wendet Filter automatisch an, wenn sich die Store-Auswahl ändert.
    \end{itemize}
    \item \textbf{renderItem:} Rendert einzelne Produktkarten mit Interaktionsmöglichkeiten.
\end{itemize}

\subsubsection{Besondere Herausforderungen}
Die Entwicklung des Search-Screens stellte verschiedene komplexe Herausforderungen dar, die innovative Lösungsansätze erforderten. Die Implementierung der Filterlogik erwies sich als besonders anspruchsvoll, da eine Kombination aus Suchbegriff, Kategorie- und Store-Filter inklusive intelligenter Sortierung realisiert werden musste. Für die Performance-Optimierung wurde FlashList eingesetzt, um auch bei großen Produktlisten ein performantes Rendering zu gewährleisten.

Die State-Synchronisation stellte eine weitere Herausforderung dar, da Filter automatisch bei Änderung der Auswahl angewendet und gleichzeitig mit dem globalen Context synchronisiert werden müssen. Besondere Aufmerksamkeit galt auch der User Experience, wobei eine durchdachte Reset- und Apply-Logik im Filter-Modal implementiert wurde, die dem Nutzer sofortige Rückmeldung bei Suche und Filterung bietet.

\section{UI-Komponenten}
\label{sec:ui_komponenten}

\subsection{Home(index)}

\subsubsection{ShoppingListItemCard}
Die Komponente ShoppingListItemCard stellt ein einzelnes Produkt in einer Einkaufsliste als interaktive Karte dar. Sie zeigt Produktinformationen und ermöglicht Swipe-Aktionen.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item Produktdaten wie Name, Marke, Preis, Menge, Einheit, Größe und Bild-URL.
    \item Optional: onPress für Klickaktionen, hasAButton für einen Aktions-Button, sowie renderRightActions und renderLeftActions für individuelle Swipe-Aktionen.
\end{itemize}

\textbf{Darstellung:}
Die Karte präsentiert sich mit abgerundeten Ecken und einem Schatten, der ihr Tiefe verleiht. Sie zeigt das Produktbild, den Namen, die Marke, den Preis und die Mengenangaben in einer übersichtlichen Anordnung. Das Bild wird dabei links positioniert, während die Produktdetails rechts daneben angezeigt werden.

\textbf{Interaktivität:}
Die Karte ist mit der Swipeable-Komponente umgeben und unterstützt Swipe-Gesten sowohl nach rechts als auch nach links. Beim Swipen nach rechts kann ein Button oder eine benutzerdefinierte Aktion angezeigt werden, was dem Nutzer schnelle Aktionsmöglichkeiten bietet. Zusätzlich kann die Karte optional per Klick ausgewählt werden, um weitere Interaktionen zu ermöglichen.

\textbf{Fehlerbehandlung:}
Das System behandelt Bildladefehler proaktiv, indem diese im Log ausgegeben werden, was bei der Fehlerdiagnose und -behebung hilft.

\noindent\textbf{Verwendung:} ShoppingListItemCard eignet sich zur Darstellung von Produkten in einer Einkaufsliste mit Swipe- und Klickfunktionen, z.B. zum Löschen, Bearbeiten oder Auswählen eines Artikels. Sie ist flexibel und kann mit verschiedenen Aktionen erweitert werden.

\subsection{Explore}

\subsubsection{CategorieField}
Die Komponente CategorieField ist ein wiederverwendbares React Native-UI-Element, das eine Kategorie als anklickbares Feld darstellt. Sie nimmt folgende Props entgegen:
\begin{itemize}
    \item \textbf{title:} Der Name der Kategorie (wird als Text angezeigt).
    \item \textbf{image:} Optionales Bild, das dekorativ rechts oben im Feld angezeigt wird.
    \item \textbf{backgroundColor:} Optionaler Hintergrundfarbwert (Standard: "\#4B946A").
    \item \textbf{onPress:} Optionaler Callback, der beim Antippen des Feldes ausgeführt wird.
\end{itemize}

\noindent\textbf{Aufbau:}
Das Haupt-Element basiert auf einem Pressable, das das gesamte Feld anklickbar macht und eine intuitive Benutzerinteraktion ermöglicht. Im Feld wird der Titel als weißer, fetter Text oben links angezeigt, was eine gute Lesbarkeit gewährleistet. Falls ein Bild übergeben wird, erscheint es dekorativ rechts oben, leicht gedreht und abgerundet, was dem Design eine moderne Note verleiht. Das Layout nutzt Tailwind-Klassen und Style-Props für ein responsives und modernes Design, das sich an verschiedene Bildschirmgrößen anpasst.

\noindent\textbf{Verwendung:} Die Komponente eignet sich hervorragend, um Kategorien in einer Übersicht darzustellen, beispielsweise in einer Liste oder einem Grid-Layout. Sie kann individuell mit Titel, Bild und Farbe angepasst und mit einer spezifischen Aktion beim Klick versehen werden, was eine hohe Flexibilität in der Anwendung ermöglicht.

\subsubsection{CategorieGroup}
Die Komponente CategorieGroup dient dazu, eine Gruppe von Kategorien als übersichtliche, responsive Felder darzustellen. Sie nimmt ein Array von Kategorien entgegen und ordnet diese in Reihen mit jeweils zwei Feldern an. Bei einer ungeraden Anzahl wird das erste Feld einzeln in einer eigenen Reihe angezeigt.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{categories:} Ein Array von Kategorie-Objekten mit Titel, Bild, Hintergrundfarbe und -optionaler Aktion.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick auf ein Feld ausgeführt wird und die jeweilige Kategorie übergibt.
\end{itemize}

\textbf{Logik:}
Die Komponente führt zunächst eine Überprüfung durch, ob Kategorien vorhanden sind, bevor sie mit der Darstellung beginnt. Bei einer ungeraden Anzahl von Kategorien wird das erste Element einzeln angezeigt, während die restlichen Kategorien paarweise gruppiert werden. Jede Reihe wird als View mit zwei Feldern (CategorieField) dargestellt, wobei unvollständige Reihen mit einem leeren Feld aufgefüllt werden, um ein konsistentes Layout zu gewährleisten.

\textbf{Layout:}
Das Design nutzt Flexbox und Tailwind-Klassen für ein modernes, flexibles Layout, das sich verschiedenen Bildschirmgrößen anpasst. Die Felder sind gleichmäßig verteilt und haben definierte Abstände zwischen den Reihen, was eine ansprechende visuelle Hierarchie schafft.

\noindent\textbf{Verwendung:} CategorieGroup eignet sich optimal, um Kategorien in einer übersichtlichen, klickbaren Grid-Ansicht darzustellen, beispielsweise auf einer Explore-Seite. Die Komponente ist flexibel gestaltet und kann individuell mit verschiedenen Aktionen und Design-Optionen erweitert werden, um spezifische Anforderungen zu erfüllen.

\subsubsection{SearchButton}
Die Komponente SearchButton ist ein klickbarer Button, der wie ein Suchfeld aussieht, aber kein Eingabefeld ist. Sie zeigt ein Lupen-Icon und einen beschrifteten Text (Standard: "Add Products") an.

\noindent\textbf{Aufbau:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{label:} Optionaler Text, der im Button angezeigt wird.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick ausgeführt wird.
\end{itemize}

\textbf{Darstellung:}
Die Komponente basiert auf einem Pressable mit abgerundeten Ecken, weißem Hintergrund und grauem Rahmen, was ihr ein sauberes und professionelles Aussehen verleiht. Das Lupen-Icon (Search aus lucide-react-native) wird links neben dem Text positioniert und signalisiert dem Nutzer die Suchfunktionalität. Der Button reagiert visuell auf Berührungen durch eine verringerte Opazität und bietet auf Android-Geräten zusätzlich einen Ripple-Effekt für taktiles Feedback.

\noindent\textbf{Verwendung:} SearchButton eignet sich hervorragend als auffälliger, interaktiver Button für Such- oder Hinzufügen-Aktionen, beispielsweise am oberen Rand einer Produktliste. Die Komponente ist einfach anpassbar und kann flexibel überall eingesetzt werden, wo ein solcher funktionaler Button benötigt wird.

\subsection{Search}

\subsubsection{SearchBar}
Die Komponente SearchBar ist eine interaktive Suchleiste für React Native, die Benutzereingaben entgegennimmt und Suchanfragen auslöst.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{placeholder:} Optionaler Platzhaltertext im Eingabefeld (Standard: "Search...").
    \item \textbf{onSearch:} Callback, der bei jeder Änderung des Suchbegriffs aufgerufen wird.
\end{itemize}

\hangindent=2em
\hangafter=1
\textbf{Ref-API:}
Über das ref kann die Methode clear von außen aufgerufen werden, um das Suchfeld zu leeren und die Tastatur zu schließen.

\textbf{Logik:}
Die Eingabe wird im State query gespeichert und jede Änderung im Textfeld löst den onSearch-Callback mit dem aktuellen Wert aus. Ein Klick auf die Leiste fokussiert das Eingabefeld automatisch, was die Benutzerfreundlichkeit erhöht. Die Methode clearSearch setzt das Feld zurück und schließt die Tastatur, um eine saubere Benutzeroberfläche zu gewährleisten.

\textbf{Darstellung:}
Die Suchleiste besteht aus einem weißen, abgerundeten Container mit einem integrierten TextInput. Das TextInput ist direkt fokussierbar und optisch schlicht gehalten, um die Aufmerksamkeit auf die Eingabe zu lenken.

\noindent\textbf{Verwendung:} SearchBar eignet sich optimal für Suchfunktionen in Listen oder Übersichten. Sie kann von außen gesteuert werden, beispielsweise zum programmatischen Zurücksetzen, und ist flexibel für verschiedene Anwendungsfälle einsetzbar.

\subsubsection{CustomMultiSelect}
Die Komponente CustomMultiSelect ist ein individuell gestaltetes Mehrfach-Auswahlfeld für React Native, basierend auf react-native-element-dropdown. Sie ermöglicht die Auswahl mehrerer Optionen aus einer Liste und bietet eine Suchfunktion.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{data:} Array von Auswahloptionen mit label und value.
    \item \textbf{labelField, valueField:} Feldnamen für Anzeige und Wert.
    \item \textbf{placeholder:} Platzhaltertext im Auswahlfeld.
    \item \textbf{value:} Array der aktuell ausgewählten Werte.
    \item \textbf{onChange:} Callback, der bei Änderung der Auswahl ausgelöst wird.
    \item Diverse Style-Props zur Anpassung des Designs.
    \item \textbf{search:} Aktiviert die Suchfunktion (Standard: true).
    \item \textbf{maxHeight:} Maximale Höhe der Dropdown-Liste.
\end{itemize}

\textbf{Darstellung:}
Die Dropdown-Liste zeigt alle verfügbaren Optionen übersichtlich an, wobei ausgewählte Elemente mit einem Haken-Icon markiert werden. Ausgewählte Items werden als Chips oberhalb der Liste angezeigt und bieten die Möglichkeit zum schnellen Entfernen über ein ×-Symbol. Die Komponente ist optisch anpassbar und nutzt Tailwind-Klassen für ein modernes Design, das sich harmonisch in verschiedene UI-Kontexte einfügt.

\textbf{Logik:}
Die Auswahl und das Entfernen von Items werden vollständig über die Props gesteuert, was eine saubere Datenhaltung gewährleistet. Die integrierte Suchfunktion filtert die angezeigten Optionen in Echtzeit und verbessert die Benutzerfreundlichkeit bei großen Datensätzen.

\noindent\textbf{Verwendung:} CustomMultiSelect eignet sich hervorragend für Filter- und Auswahlfunktionen, bei denen mehrere Werte gleichzeitig gewählt werden können, beispielsweise zur Produktsuche oder Kategoriefilterung. Sie ist flexibel gestaltet und lässt sich einfach in verschiedene UI-Kontexte integrieren.

\subsection{(Produkt-)Details}

\subsubsection{Field}
Die Komponente Field ist ein flexibler, klickbarer Button für React Native, der ein Icon und optional einen Text anzeigt.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{icon:} Das anzuzeigende Icon (React-Komponente).
    \item \textbf{text:} Optionaler Text, der neben dem Icon angezeigt wird.
    \item \textbf{iconColor:} Farbe des Icons (wird über das Icon selbst gesteuert).
    \item \textbf{backgroundColor:} Hintergrundfarbe des Buttons.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick ausgeführt wird.
\end{itemize}

\textbf{Darstellung:}
Der Button präsentiert sich mit abgerundeten Ecken und ist horizontal ausgerichtet und zentriert angeordnet. Das Icon wird links positioniert, während der Text, falls vorhanden, rechts daneben platziert wird. Der Hintergrund ist individuell anpassbar, was eine flexible Gestaltung ermöglicht. Die Klick-Animation wird über activeOpacity gesteuert und bietet dem Nutzer visuelles Feedback bei der Interaktion.

\noindent\textbf{Verwendung:} Field eignet sich für verschiedene Interaktionsmöglichkeiten, beispielsweise als Mengen-Auswahl, Aktions-Button oder für Eingabefelder mit Icon-Unterstützung. Das Design ist flexibel angelegt und kann mit unterschiedlichen Icons, Farben und Texten verwendet werden, um verschiedene Anwendungsfälle abzudecken.

\subsubsection{QuantityInput}
Die Komponente QuantityInput ist ein Eingabefeld für Mengenangaben, das Benutzern ermöglicht, eine Zahl durch Plus- und Minus-Buttons zu erhöhen oder zu verringern.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{value:} Startwert der Menge (Standard: 1).
    \item \textbf{onChange:} Callback, der bei jeder Änderung der Menge ausgelöst wird.
    \item \textbf{min, max:} Minimale und maximale erlaubte Werte (Standard: 1 bis 99).
\end{itemize}

\textbf{Logik:}
Die aktuelle Menge wird im State quantity verwaltet und bietet eine zentrale Kontrolle über den Wert. Beim Klick auf den Minus-Button wird die Menge um eins verringert, solange sie über dem definierten Minimum liegt. Entsprechend wird beim Klick auf den Plus-Button die Menge um eins erhöht, solange sie unter dem festgelegten Maximum bleibt. Jede Änderung löst den onChange-Callback mit dem neuen Wert aus, was eine nahtlose Integration in übergeordnete Komponenten ermöglicht.

\textbf{Darstellung:}
Die Komponente besteht aus einer horizontal angeordneten Reihe mit einem Minus-Button, der zentralen Mengenanzeige und einem Plus-Button. Die Buttons sind rund gestaltet und heben sich optisch deutlich ab, während die aktuelle Menge mittig und gut lesbar angezeigt wird.

\noindent\textbf{Verwendung:} QuantityInput eignet sich optimal für Produktdetailseiten oder Warenkörbe, wo Nutzer die gewünschte Menge eines Artikels präzise einstellen können. Sie ist intuitiv bedienbar und flexibel in verschiedenen Kontexten einsetzbar.

\subsubsection{ProductLoadingSkeleton}
Die Komponente ProductLoadingSkeleton zeigt ein Ladeplatzhalter-Layout für Produktdetailseiten an, während die echten Daten geladen werden.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Darstellung:}
Die Komponente besteht aus mehreren grauen, animierten Rechtecken (``Skeletons''), die die Struktur der später angezeigten Produktinformationen nachahmen und dem Nutzer eine Vorschau auf das kommende Layout bieten. Es sind Platzhalter für das Produktbild, den Titel, Varianten, Angebote und einen Button vorhanden, die alle wichtigen Bereiche der Produktdetailseite abdecken. Die Platzhalter sind mit der Klasse animate-pulse versehen, um eine pulsierende Ladeanimation darzustellen, die Aktivität signalisiert und die Wartezeit angenehmer gestaltet.

\textbf{Layout:}
Die Elemente sind optisch so angeordnet, wie die echten Produktdetails später erscheinen werden, was eine nahtlose Transition gewährleistet. Das Layout ist responsiv gestaltet und zentriert ausgerichtet, um auf verschiedenen Bildschirmgrößen optimal zu funktionieren.

\noindent\textbf{Verwendung:} ProductLoadingSkeleton wird angezeigt, wenn Produktdaten noch nicht vollständig geladen sind, um dem Nutzer visuelles Feedback zu geben und die Wartezeit angenehmer zu gestalten. Sie verbessert die User Experience erheblich durch ein modernes Lade-Design, das Transparenz über den Ladezustand schafft und die wahrgenommene Ladezeit reduziert.

\vspace{1em}
\noindent
Dieses Kapitel liefert einen Rahmen für die Dokumentation der Benutzeroberfläche und kann im Laufe des Projekts kontinuierlich mit Inhalten, Screenshots und technischen Details erweitert werden.


\end{document}
