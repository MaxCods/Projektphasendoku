%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                            %
%      Projektdokumentation: Smart Shopping App                              %
%                                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt, a4paper]{report} % report ermöglicht Kapitelstruktur

% --- PRÄAMBEL: Notwendige Pakete ---
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{marginnote}


% --- SEITENLAYOUT ---
\geometry{a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}
\setlength{\headheight}{15pt}

% --- HYPERLINKS ---
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

% --- CODE-LISTING-STILE ---

% Python-Stil
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}
\lstset{style=pythonstyle}

% JSON-Stil
\lstdefinelanguage{JSON}{
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\tiny\color{codegray},
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=lines,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{blue}, % Schlüsselwörter wie true, false, null
  stringstyle=\color{codepurple},
  morestring=[b]",
  moredelim=[il][\textcolor{codegray}]{:},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
}

% --- TYPECRIPT-LISTINGS-STIL ---
\lstdefinelanguage{TypeScript}{
  keywords={
    abstract, any, as, async, await, boolean, break, byte, case, catch, char, class,
    const, continue, debugger, declare, default, delete, do, else, enum, export, extends,
    false, final, finally, for, from, function, get, if, implements, import, in, infer,
    instanceof, interface, is, keyof, let, module, namespace, never, new, null, number,
    object, of, package, private, protected, public, readonly, require, return, set,
    static, string, super, switch, symbol, this, throw, true, try, type, typeof, var,
    void, while, with, yield
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  moredelim=[il][\color{codegray}]{:},
}

\lstdefinestyle{typescriptstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=TypeScript
}

% --- KOPF- UND FUSSZEILEN ---
\newcommand{\authorinitials}{} % Default leer
\newcommand{\authormark}[1]{\marginnote{\scriptsize \textsf{#1}}}

% EINZELNER ABSCHNITT:
% Dieser Abschnitt beschreibt die Datenbankarchitektur. \authormark{MK}

% GANZE KAPITEL:
% \chapter{Tech Stack und Architekturentscheidungen}
% \renewcommand{\authorinitials}{DH}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{Smart Shopping App}
\fancyhead[R]{\nouppercase{\leftmark}}
\fancyfoot[C]{\thepage}
\fancyfoot[L]{\authorinitials}

\fancypagestyle{plain}{
  \fancyhf{}
  \fancyhead[L]{Smart Shopping App}
  \fancyhead[R]{\nouppercase{\leftmark}}
  \fancyfoot[C]{\thepage}
  \fancyfoot[L]{\authorinitials}
}


% --- BEGINN DES DOKUMENTS ---
\begin{document}

% Titelseite
% TODO: Matrikelnummern eintragen
\begin{titlepage}
    \centering
    \vspace*{4cm}
    {\LARGE\bfseries Projektdokumentation \par}
    \vspace{1.5cm}
    {\Large \textbf{Smart Shopping App} \\[3mm]}
    \vspace{1cm}
    {\large für das Modul\\
      Programmierprojekt / Softwareentwicklungsprojekt\\}
    \vspace{1.5cm}
    {\large
      \textbf{Teammitglieder:}\\[5mm]
      David Heppenheimer (DH)\\
      Maximilian Keller (MK)\\
      Nikolas Keller (NK)\\
      Max Tremel (MT)\\
      Finn Krappitz (FK)
    }
    \vfill
    {\large \today}
\end{titlepage}

\tableofcontents
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TECHNOLOGIE-ÜBERBLICK UND ENTSCHEIDUNGSFINDUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tech Stack und Architekturentscheidungen}
\renewcommand{\authorinitials}{DH}


\label{chap:tech_stack}

\section{Ziel der App}
Die Smart Shopping App verfolgt das Ziel, Nutzer:innen bei der Planung ihres Wocheneinkaufs möglichst kosteneffizient zu unterstützen. Anhand einer individuell erstellten Einkaufsliste werden sowohl reguläre Grundpreise als auch zeitlich begrenzte Angebots­preise aus digitalen Prospekten berücksichtigt, um für den gesamten Warenkorb den günstigsten Supermarkt zu ermitteln. Dieses ambitionierte Vorhaben erfordert eine sorgfältige Auswahl und Kombination von Frontend-Technologien, Backend-Architektur, Datenbanklösungen, Authentifizierungsdiensten sowie einer robusten Data-Engineering-Pipeline.

\section{Überblick über den Technologie-Stack}
Um den hohen Anforderungen an Performance, Wartbarkeit, Skalierbarkeit und Entwicklungsgeschwindigkeit gerecht zu werden, haben wir unseren Tech Stack in fünf Hauptkomponenten gegliedert: das mobile Frontend, die Backend-API, die relationale Datenbank, den Authentifizierungsdienst und die Data-Engineering-Schicht für das Web Scraping.

\section{Frontend}
\subsection{Technologien: Expo Go, React Native und NativeWind}
Für das mobile Frontend setzen wir auf Expo Go in Kombination mit React Native. Diese Wahl erlaubt es, mit nur einer Codebasis Applikationen für iOS und Android zu realisieren, was Entwicklungs- und Testaufwände deutlich reduziert. Durch Expo Go entfällt der aufwendige Build-Prozess nativer Apps: Änderungen am UI werden direkt auf realen Geräten oder in Simulatoren sichtbar, was die Iterationszyklen verkürzt und eine enge Feedback-Schleife ermöglicht.

Als Styling-System dient NativeWind, eine Tailwind-CSS-Adaption für React Native. Mit Utility-Klassen lassen sich konsistente Designs ohne umfangreiche Stylesheets implementieren, was den Boilerplate-Aufwand minimiert und die Wartbarkeit steigert.

\subsection{Alternative Ansätze}
Alternativ zum React-Native-Ansatz standen Frameworks wie Flutter oder Web-View-basierte Lösungen (Ionic/Cordova) zur Debatte. Flutter glänzt mit hoher Rendering-Performance und einem reichhaltigen Widget-Ökosystem, erfordert jedoch den Einsatz von Dart und eine neue Lernkurve für das Team. Ionic und Cordova ermöglichen schnellen Einstieg über HTML/CSS in einer Web-View, sind aber in puncto nativer Performance und Hardware-Integration limitiert. Die Entscheidung fiel schließlich auf Expo/React Native, da wir auf JavaScript/TypeScript-Kompetenz im Team aufbauen und den Vorteil der breiten Community nutzen wollten.

\section{Backend}
\subsection{Technologieauswahl: Node.js mit Express}
Als Backend-API kommt Node.js mit dem minimalistischen Framework Express zum Einsatz. Express bietet eine schlanke, unopinionated Basis für den Aufbau von REST-Endpunkten und lässt sich durch Middleware flexibel erweitern. In Verbindung mit TypeScript erreichen wir durch typgesicherte Routen und Datenmodelle bereits zur Entwicklungszeit eine hohe Fehlerfrüherkennung.

\subsection{Datenbankzugriffe mit Prisma}
Für die Datenbankzugriffe verwenden wir Prisma als ORM. Prisma ermöglicht es, Datenbankschemata deklarativ in einer schema.prisma-Datei zu definieren und mit Migrationsskripten (prisma migrate) versioniert auszurollen. Die generierten TypeScript-Clients bieten eine typgesicherte API für alle CRUD-Operationen und fangen schon zur Kompilierzeit viele Fehler ab.

Ein typisches Beispiel für die Definition eines Prisma-Modells in der Schema-Datei sieht wie folgt aus:

\begin{lstlisting}[language=TypeScript,caption={Schema-Definition mit Prisma}]
model Product {
id        Int      @id @default(autoincrement())
name      String
price     Float
store     String
createdAt DateTime @default(now())
}
\end{lstlisting}

Nach dem Befehl npx prisma migrate dev --name init wird die Migration eingespielt und der Prisma Client generiert. Im Code kann man den Client dann wie im folgenden Beispiel verwenden:

\begin{lstlisting}[style=typescriptstyle,caption={Beispielhafte Verwendung des Prisma Client}]
    import { PrismaClient } from "@prisma/client";
    import express from "express";
    
    const prisma = new PrismaClient();
    const app = express();
    
    app.use(express.json());
    
    app.post('/products', async (req, res) => {
      const { name, price, store } = req.body;
      try {
        const newProduct = await prisma.product.create({
          data: { name, price, store },
        });
        console.log("Created product:", newProduct);
        res.status(201).json(newProduct);
      } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Fehler beim Anlegen des Produkts.' });
      }
    });
    
    app.listen(3000, () => {
      console.log("Server laeuft auf Port 3000");
    });
    \end{lstlisting}

\subsection{Authentifizierung mit Clerk}
Zur Authentifizierung und zum User-Management setzen wir Clerk ein. Clerk ist eine Identity‑as‑a‑Service‑Plattform, die vollständig vorkonfigurierte Anmelde‑ und Registrierungsflüsse sowie Passwort‑Zurücksetzen‑Funktionalitäten bereitstellt. Zusätzlich unterstützt Clerk Social‑Login‑Anbieter wie Google, Facebook und Apple und ermöglicht Single‑Sign‑On (SSO) für nahtlose Benutzererlebnisse. Multi‑Faktor‑Authentifizierung (MFA) inklusive E‑Mail‑ und SMS‑Verifizierung ist standardmäßig integriert, ebenso wie Features wie Brute‑Force‑Schutz, automatisches Session‑Timeout und Token‑Revokation.

Mittels der offiziellen React- und React Native SDKs können wir Clerk‑UI-Komponenten direkt in unsere Expo App integrieren, Benutzerattribute verwalten und Zugriffsrechte über Claims abbilden. Clerk übernimmt das komplette Session‑Management sowie die sichere Speicherung von Benutzerdaten nach GDPR‑Standards, wodurch wir erheblichen Entwicklungs- und Wartungs­aufwand für eigene Authentifizierungslösungen einsparen und gleichzeitig hohe Sicherheits- und Compliance-Vorgaben erfüllen.

\subsection{Alternativen zum Backend-Stack}
Im Vergleich dazu hätten wir auch auf umfassendere Frameworks wie NestJS setzen können, das mit Dependency Injection und Modulen ein höheres Maß an Struktur und Konventionen bietet. Allerdings bringt NestJS eine steilere Lernkurve und mehr Boilerplate mit sich. Auch Python-Frameworks wie Django oder Flask waren im Gespräch: Django punktet mit einem integrierten Admin-Interface, erfordert aber eine zusätzliche Sprache im Projekt.

\section{Datenbank}
\subsection{Wahl von PostgreSQL}
Für die persistente Speicherung nutzen wir PostgreSQL. Neben bewährter ACID-Konformität und Transaktions­sicherheit profitieren wir von leistungsfähigen Features wie JSONB-Feldern für flexible Metadaten und komplexen Abfragen. Die umfangreichen Backup- und Replikations­mechanismen stellen den langfristigen Betrieb unter wachsendem Datenaufkommen sicher.

\subsection{Alternative Datenbanken}
Als Alternative standen relationale Systeme wie MySQL/MariaDB oder NoSQL-Datenbanken wie MongoDB zur Auswahl. MySQL bietet ähnliche Stabilität, ist jedoch in JSON-Operationen etwas eingeschränkter. MongoDB punktet mit schemaloser Flexibilität, macht aber konsistente Joins und Transaktions­szenarien deutlich aufwendiger.

\section{Data-Engineering und Web Scraping}
\subsection{Technologiewahl und Vorgehen}
Die Preis- und Angebotsdaten erfassen wir mit Python: Selenium steuert einen echten Browser, um dynamisch nachgeladene Inhalte zuverlässig zu extrahieren, und BeautifulSoup übernimmt das strukturierte Parsen des resultierenden HTML. Ein klar getrenntes Zwei-Stufen-Konzept – ein Basisscraping für Name, Preis und Detail-URLs, gefolgt von einem Enrichment-Durchlauf für Marken-, Verpackungs- und Bildinformationen – sorgt für Modularität und Fehlertoleranz. Beide Schritte nutzen concurrent.futures.ThreadPoolExecutor zur Parallelisierung, um Laufzeiten zu minimieren. In den folgenden Kapiteln gehen wir detailliert auf die einzelnen Scraping- und Enrichment-Prozesse ein.

\section{Zusammenfassung}
Die gewählte Architektur aus Expo/React Native, Express/Prisma/Clerk, PostgreSQL und Python-Scraping schafft eine ausgewogene Balance zwischen schneller Frontend-Entwicklung, typgesicherter Backend-Logik, sicherer Authentifizierung, zuverlässiger Datenhaltung und robustem Data-Engineering. Diese Basis ermöglicht es, die folgenden Kapitel – von Web Scraping über API-Design bis zur UI-Implementierung – konsistent und zielführend weiterzuführen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SCRAPER-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Web Scraping zur Erfassung von Produktdaten}
\renewcommand{\authorinitials}{MK}
\label{chap:web_scraping}

\section{Einleitung, ursprünglicher Umfang und finale Problemstellung}
Die Grundlage für dieses Projekt bildete die Notwendigkeit, umfassende und aktuelle Produktdaten von deutschen Supermarktketten zu akquirieren. Hierbei wurde eine strategische Trennung vorgenommen: Die in diesem Kapitel beschriebenen Scraper konzentrieren sich auf die Erfassung der regulären \textbf{Grundpreise} direkt von den Webseiten der Einzelhändler. Parallel dazu wird die Erfassung von zeitlich begrenzten \textbf{Angebotspreisen} über einen separaten Scraper realisiert, der die Daten der Prospekt-Plattform \textit{Marktguru} für eine breitere Auswahl an Märkten ausliest. Die technische Umsetzung dieses Angebot-Scrapers wird in einem gesonderten Kapitel behandelt.

Der anfängliche Anspruch für das hier dokumentierte Grundpreis-Scraping war äußerst ambitioniert: Es sollten die Sortimente einer breiten Palette von Einzelhändlern erfasst werden, darunter \textbf{REWE, EDEKA, Lidl, Kaufland, Marktkauf, tegut, Norma, Aldi Nord} und \textbf{Aldi Süd}.

Eine erste Sondierungsphase offenbarte jedoch schnell erhebliche technische und strukturelle Hürden. Viele der untersuchten Webseiten implementieren hochentwickelte Schutzmechanismen gegen automatisierte Datenabfragen, weisen extrem komplexe und inkonsistente Seitenstrukturen auf oder bieten kein vollständiges Online-Produktsortiment, das für ein systematisches Scraping zugänglich wäre.

Angesichts dieser Herausforderungen wurde eine strategische Entscheidung getroffen: Der Fokus des Projekts wurde auf jene Anbieter reduziert, bei denen eine zuverlässige und wiederholbare Datenerfassung im gegebenen Zeitrahmen realisierbar erschien. Letztendlich konzentrierte sich die Entwicklungsarbeit erfolgreich auf die Webauftritte von \textbf{Aldi Nord}, \textbf{Aldi Süd} und \textbf{Netto}.

Die zentrale technische Herausforderung bei diesen Zieldomänen bestand darin, dass moderne Webseiten Inhalte nicht mehr als statische HTML-Dokumente ausliefern. Stattdessen werden Produktlisten dynamisch mittels JavaScript nachgeladen. Dies erforderte eine sorgfältige Analyse der verbleibenden Webseitenstrukturen und die Auswahl einer robusten Technologie, die in der Lage ist, eine reale Benutzerinteraktion zu simulieren, um die vollständigen und korrekten Daten zu extrahieren.

\section{Technologie-Evaluierung und strategische Entscheidung}
\subsection{Erster Ansatz: Requests und BeautifulSoup}
Der initiale Plan sah vor, die Daten mit einer Kombination der Python-Bibliotheken \texttt{requests} und \texttt{BeautifulSoup} zu extrahieren. Dieser Ansatz scheiterte jedoch schnell aus zwei Hauptgründen:
\begin{enumerate}
    \item \textbf{Dynamisches Laden von Inhalten:} Bei der Analyse des von \texttt{requests} abgerufenen HTML-Codes wurde festgestellt, dass die Produktlisten fehlten. Die Webseiten laden die Produkte erst nach dem initialen Laden der Seite über JavaScript-APIs nach. \texttt{requests} führt kein JavaScript aus und erhält somit nur das initiale, unvollständige HTML-Dokument.
    \item \textbf{Bot-Erkennung:} Webseiten nutzen verschiedene Techniken, um automatisierte Skripte zu erkennen. Dazu gehören die Analyse des \texttt{User-Agent}-Headers oder die Überprüfung von Verhaltensmustern. Obwohl Header manuell gesetzt werden können, sind diese einfachen Maßnahmen oft nicht ausreichend.
\end{enumerate}

\subsection{Die Lösung: Selenium WebDriver}
Aufgrund der Unzulänglichkeiten des ersten Ansatzes fiel die Wahl auf \textbf{Selenium}. Selenium ist ein Framework zur Automatisierung von Webbrowsern, das eine echte Browser-Instanz (z.B. Google Chrome) steuert.

Dies bietet entscheidende Vorteile:
\begin{itemize}
    \item \textbf{Vollständiges Rendern der Seite:} Da ein echter Browser verwendet wird, wird sämtliches JavaScript ausgeführt. Dynamisch nachgeladene Inhalte sind somit im gerenderten HTML-DOM vorhanden und können extrahiert werden.
    \item \textbf{Simulation von Benutzerinteraktionen:} Selenium kann Aktionen wie das Scrollen der Seite oder das Klicken auf "`Mehr anzeigen"'-Buttons simulieren, um alle Produkte sichtbar zu machen.
    \item \textbf{Umgehung von Bot-Erkennung:} Durch die Steuerung eines echten Browsers erscheint die Interaktion für den Server weitaus menschlicher. Zusätzlich wurden in den Skripten Konfigurationen vorgenommen, um die Automatisierung weiter zu verschleiern.
\end{itemize}
Die Kombination aus Selenium zum Laden der Seite und BeautifulSoup zum Parsen des resultierenden HTML-Codes (\texttt{driver.page\_source}) erwies sich als die robusteste und erfolgreichste Methode.

\section{Implementierungsdetails: Ein zweistufiger Prozess}
\label{sec:scraping_prozess}
Im Verlauf der Entwicklung kristallisierte sich heraus, dass ein monolithischer Ansatz, bei dem alle Daten in einem einzigen Durchgang erfasst werden, ineffizient und fehleranfällig ist. Daher wurde ein robusterer, zweistufiger Prozess implementiert, bestehend aus einem initialen \textbf{Scraping}-Lauf und einem nachgelagerten \textbf{Anreicherungs}-(Enrichment)-Lauf.

\subsection{Strategische Trennung der Prozessschritte}
Der ursprüngliche Plan sah vor, dass der Scraper eine Kategorieseite lädt, die Links zu allen Produkten extrahiert und dann sofort jede dieser Produkt-Detailseiten einzeln aufruft, um sämtliche Informationen zu sammeln. Dieser Ansatz wurde verworfen, da er die Gesamtlaufzeit massiv erhöht und die Fehlerbehandlung verkompliziert hätte. Die Trennung brachte entscheidende Vorteile wie Robustheit, Effizienz und Modularität.

\subsection{Stufe 1: Der Scraping-Prozess}
In der ersten Stufe konzentrieren sich die Scraper-Skripte (z.B. \texttt{aldi\_sued\_scraper.py}) darauf, schnell die wesentlichen Basisdaten von den Kategorieseiten zu sammeln. Nach einer verworfenen Idee der vollständigen Automatisierung wurde entschieden, die URLs der Kategorieseiten \textbf{manuell zu pflegen}, um die Zuverlässigkeit zu erhöhen.

Der Ablauf für jede URL ist wie folgt:
\begin{enumerate}
    \item \textbf{Browser-Initialisierung und Seitenaufruf:} Starten einer konfigurierten Selenium-WebDriver-Instanz und Navigation zur Ziel-URL.
    \item \textbf{Interaktion:} Akzeptieren von Cookie-Bannern und Ausführen von Aktionen wie Scrollen und Klicken auf "`Mehr anzeigen"'-Buttons, um alle Produkte zu laden.
    \item \textbf{Basis-Datenextraktion:} Übergabe des Seitenquelltextes an BeautifulSoup und Extraktion der Kerninformationen: \textbf{Name, Preis} und die \textbf{URL zur Produkt-Detailseite}.
\end{enumerate}
Das Ergebnis dieses ersten Schrittes ist eine JSON-Datei (z.B. \texttt{aldi\_sued\_products\_latest.json}), die eine Liste von Produkten mit diesen rohen Basis-Informationen enthält.

\subsection{Stufe 2: Der Anreicherungsprozess (Enrichment)}
In der zweiten Stufe kommen die Enricher-Skripte (z.B. \texttt{aldi\_nord\_enricher.py}) zum Einsatz. Sie lesen die vom Scraper erstellte JSON-Datei ein und veredeln die Daten, indem sie jede Produkt-URL aufrufen und Detailinformationen extrahieren.

Der Enricher erledigt folgende Aufgaben:
\begin{enumerate}
    \item \textbf{Aufruf der Produkt-URL:} Für jedes Produkt wird die Detailseiten-URL aufgerufen, meist mit der schnelleren `requests`-Bibliothek, da diese Seiten oft statischer sind.
    \item \textbf{Übergabe des HTML-Codes an BeautifulSoup:} Der HTML-Code der Produktseite wird an BeautifulSoup übergeben, um die zusätzlichen Informationen zu extrahieren.
    \item \textbf{Extraktion von Detailinformationen:} Von der Produktseite werden zusätzliche Daten gesammelt:
        \begin{itemize}
            \item \textbf{Markenname}
            \item \textbf{Hochauflösende Bild-URL}
            \item \textbf{Detaillierte Grundpreis-Angaben} und Verpackungsbeschreibungen
        \end{itemize}
    \item \textbf{Aktualisierung und Speicherung:} Die neuen Informationen werden dem bestehenden Datensatz hinzugefügt und in einer neuen, angereicherten JSON-Datei (z.B. \texttt{aldi\_nord\_products\_enriched\_latest.json}) gespeichert.
\end{enumerate}

\section{Performance-Optimierung durch Parallelisierung}
\label{sec:scraping_performance}
Ein Hauptproblem war die lange Ausführungszeit. Die Lösung war die Implementierung von paralleler Ausführung in \textbf{beiden Prozessschritten} mithilfe des \texttt{concurrent.futures.ThreadPoolExecutor} aus der Python-Standardbibliothek.

Anstatt die URLs sequenziell abzuarbeiten, wird ein "`Pool"' von Worker-Threads erstellt. Jeder Thread erhält eine URL und führt den Scraping- bzw. Anreicherungsprozess unabhängig und gleichzeitig zu den anderen Threads aus.

\begin{lstlisting}[language=Python, caption={Parallele Ausführung mit ThreadPoolExecutor}]
max_workers = min(20, len(URLS))
with ThreadPoolExecutor(max_workers=max_workers) as executor:
    # Starte die Scraping- oder Enriching-Aufgaben
    future_to_url = {executor.submit(process_url_function, url): url for url in URLS}
    
    for future in as_completed(future_to_url):
        url = future_to_url[future]
        try:
            result = future.result()
            # Ergebnisse verarbeiten...
        except Exception as exc:
            logger.error(f"URL {url} hat eine Ausnahme erzeugt: {exc}")
\end{lstlisting}
Durch diese Parallelisierung konnte die Gesamtdauer für die Datenerfassung von mehreren Stunden auf einen Bruchteil dieser Zeit reduziert werden.

\section{Datenspeicherung und finale Datenstruktur}
\label{sec:scraping_datenspeicherung}
Die extrahierten und bereinigten Produktdaten werden im \textbf{JSON-Format} gespeichert. Der zweistufige Prozess spiegelt sich auch in der Dateibenennung wider:
\begin{enumerate}
    \item \textbf{Scraper-Output:} Der erste Schritt erzeugt eine Datei wie \texttt{\ldots\_products\_latest.json}.
    \item \textbf{Enricher-Output:} Der zweite Schritt liest diese Datei ein und erzeugt eine angereicherte Zieldatei, z.B. \texttt{\ldots\_products\_enriched\_latest.json}.
\end{enumerate}

Für jeden Lauf wird eine neue JSON-Datei mit einem Zeitstempel im Dateinamen erstellt. Zusätzlich wird eine Datei mit dem Suffix \texttt{\_latest.json} erzeugt oder aktualisiert, die immer die Daten des letzten erfolgreichen Laufs enthält. Dies erleichtert den Zugriff für nachfolgende Prozessschritte.

Die Struktur der finalen, angereicherten JSON-Datei ist wie folgt aufgebaut:
\begin{lstlisting}[language=JSON, caption={Beispielhafte JSON-Struktur der finalen Ausgabedatei}]
{
  "metadata": {
    "source": "aldi_sued",
    "scraped_at": "2025-07-20 15:43:00",
    "total_products": 458
  },
  "products": [
    {
      "store": "aldi_sued",
      "name": "Bio Eier",
      "price": 3.29,
      "brand": "GUT BIO",
      "unit": "Stueck",
      "size": "10",
      "url": "https://www.aldi-sued.de/p/...",
      "image_url": "https://..."
    },
    {
      "store": "aldi_sued",
      "name": "Nutella",
      "price": 4.99,
      "brand": "Ferrero",
      "unit": "g",
      "size": "750",
      "url": "https://...",
      "image_url": "https://..."
    }
  ]
}
\end{lstlisting}
Diese strukturierte Ausgabe bildet die saubere und zuverlässige Datenbasis für alle weiteren Analysen und Verarbeitungsschritte im Projekt.

\section{Import der Produktdaten in die Datenbank: Normalisierung \& Matching}

Nach der erfolgreichen Extraktion und Anreicherung der Produktdaten folgt ein zentraler Schritt in der gesamten Data-Engineering-Pipeline: Das zuverlässige und konsistente Importieren aller Produkte in die zentrale Datenbank. Dieser Abschnitt beschreibt detailliert, wie das Import-Skript arbeitet, welche Herausforderungen bezüglich Datenkonsistenz und Matching identifiziert wurden und wie sie durch gezielte Normalisierungs- und Matchingstrategien gelöst wurden.

\subsection{Ablauf und technische Einbettung des Imports}

Der Importprozess wird als eigenständiges Node.js-Skript implementiert und initialisiert nach dem Laden der Scraping-Ergebnisse die Verbindung sowohl zur Datenbank als auch zum Storage für Produktbilder. Mit Hilfe von Prisma als ORM werden sämtliche Datenbankzugriffe typgesichert und migrationssicher ausgeführt.

\begin{enumerate}
    \item \textbf{Dateisuche \& Laden:} Zunächst werden automatisiert alle relevanten JSON-Dateien (aus unterschiedlichen Scraper-Quellen/Stores) gefunden, eingelesen und in ein gemeinsames Produktarray umgewandelt. Dabei wird bereits der Store-Name jedem Produkt zugeordnet.
    \item \textbf{Batch-Import (Parallelisierung):} Um die große Produktmenge effizient zu verarbeiten, werden die Produkte in Batches (z. B. à 50 Produkte) aufgeteilt und jeweils mehrere Batches parallel importiert. Innerhalb eines Batches erfolgt die interne Verarbeitung wiederum parallel, aber mit sorgfältigem Race-Condition-Handling.
    \item \textbf{Produktverarbeitung:} Für jedes Produkt erfolgt jetzt ein mehrstufiger Importvorgang (siehe Algorithmus unten).
\end{enumerate}

\subsection{Daten-Normalisierung für zuverlässiges Matching}

Eine der größten Herausforderungen beim Import mehrerer Produktdaten aus unterschiedlichen Quellen besteht darin, identische oder faktisch gleiche Produkte zu erkennen und eindeutig in der Datenbank zu verknüpfen. Ein simples Abgleichen von Produktnamen führt angesichts unterschiedlichster Schreibweisen, Mengenangaben, Sonderzeichen und Dateninkonsistenzen schnell zu fehlerhaften Duplikaten oder nicht erkannten Matches.

\textbf{Die wichtigsten Normalisierungsschritte sind:}

\begin{itemize}
    \item \textbf{Name:}
      \begin{itemize}
        \item Entfernen von führenden/trailing Leerzeichen, Sonderzeichen und überflüssigen Kommas
        \item Vereinheitlichung durch Kleinschreibung und Entfernen von Akzentzeichen (z.B. "`Crème fraîche"' $\to$ "`creme fraiche"')
        \item Extra-Parsing von Mengenangaben (z. B. "`10 x 50g"' $\to$ 500g Gesamtgewicht)
      \end{itemize}
    \item \textbf{Marke:}
      \begin{itemize}
        \item Ebenfalls Normalisierung per Großschreibung und Entfernen von Akzenten (z.B. "`NESTLÉ"' $\to$ "`NESTLE"')
        \item Konsistenter Vergleich entgegen verschiedenster Schreibweisen der Herstellerseiten
      \end{itemize}
    \item \textbf{Menge und Einheit:}
      \begin{itemize}
        \item Intelligente Korrektur offensichtlicher Einheiten-Fehler (z.B. "`500-kg-Packung"' bei typischen Lebensmittelgrößen als "`500-g-Packung"' korrigieren)
        \item Parsing-Logik erkennt und vereinheitlicht alle häufigen Darstellungen (z.B. "`ml/l"', "`gr/kg"', "`Stück"')
      \end{itemize}
    \item \textbf{Kategorie:}
      \item Die Einordnung in eine oder mehrere Kategorien wird automatisiert mit einem eigens entwickelten "`CategoryDetector"' durchgeführt, der nach Mustern in Produktnamen sucht.
\end{itemize}

\subsubsection{Codebeispiel: Name-Normalisierung}
\begin{lstlisting}[language=TypeScript, caption={Vereinheitlichung von Produktnamen}]
export function cleanProductName(name: string): string {
  if (!name) return name;
  return name
    .trim()                   // Leerzeichen entfernen
    .replace(/[\s,]+$/, "")   // Kommas & Leerzeichen am Ende entfernen
    .toLowerCase();
}
\end{lstlisting}

\subsection{Matching-Strategie: Wie werden gleiche Produkte erkannt?}

Eine der Kernausforderungen war es, die \emph{gleichen} Produkte unterschiedlicher Supermärkte als eindeutige Entitäten in der Datenbank zu pflegen, sodass für einen Produktvergleich marktübergreifende Preise angezeigt werden können.

\textbf{Der Matching- und Import-Algorithmus arbeitet wie folgt:}
\begin{enumerate}
    \item \textbf{Normalisierung:} Jeder Produktdatensatz wird zunächst durch den Normalisierer geschickt: Name, Marke, Menge, Einheit usw.
    \item \textbf{Brand-Handling:}
        \begin{itemize}
            \item Für jede Marke wird diese zuerst im Cache gesucht (zur Minimierung von Datenbankzugriffen), ansonsten case-insensitiv per Upsert in der Datenbank erzeugt/gefunden.
        \end{itemize}
    \item \textbf{Produkt-Suche:}
        \begin{itemize}
            \item Produktsuche erfolgt nach normalisiertem Namen und zugehöriger Marke. Gibt es bereits ein solches Produkt in der Datenbank (Name und Brand), wird dieses weiter verwendet, ansonsten neu angelegt.
        \end{itemize}
    \item \textbf{Produktvariante:}
        \begin{itemize}
            \item Jede Produktvariante (z.B. "`500g"' oder "`1l"'-Version derselben Ware) bekommt einen eindeutigen Identifier (ProduktID + Größe/Einheit).
        \end{itemize}
    \item \textbf{Store-Angebot (Preis je Markt):}
        \begin{itemize}
            \item Für jede Kombination aus Markt und Produktvariante wird ein Preis-Datensatz geschrieben/aktualisiert. Race-Conditions durch parallele Importe werden durch explizite Fehlerbehandlung im Upsert-Prozess abgefangen.
        \end{itemize}
    \item \textbf{Kategorien:}
        \begin{itemize}
            \item Jede Variante erhält alle passenden Kategorien laut Detektor, Mehrfachzuweisungen werden durch Many-to-many-Relationen abgebildet.
        \end{itemize}
    \item \textbf{Bilder:}
        \begin{itemize}
            \item Produktbilder werden pro Variante verwaltet und versioniert im Object Storage abgelegt.
        \end{itemize}
\end{enumerate}

\subsubsection{Race-Condition-Handling und Performance}
Da viele Importe parallel ablaufen, besteht die Gefahr, dass exakt in diesem Moment zwei Prozesse denselben Datensatz neu anlegen möchten. Daher wird systematisch mit sogenannten "`Upserts"' (Prisma ORM) gearbeitet: Es wird nach einem Datensatz gesucht, ansonsten neu angelegt, und im Fehlerfall (z.B. Unique Constraint) nochmals abgeglichen. Eigene Map-Caches für Marken, Kategorien und Stores verhindern unnötig viele DB-Zugriffe.

\subsubsection{Auszug aus dem Import-Algorithmus}
\begin{lstlisting}[style=typescriptstyle, caption={Produkt-Import: Algorithmus bei Name-Matching und DB-Schreibvorgang}]
// 1. Brand normalisieren & upsert
const normalizedBrand = normalizeAccents(product.brand.toUpperCase());
// 2. Produkt nach (name + brand) suchen oder neu anlegen
let product_db = await prisma.product.findFirst({
   where: { name: productName, brandId: brand?.id || null }
});
if (!product_db) {
  product_db = await prisma.product.create({
    data: { name: productName, brandId: brand?.id || null, /* ... */ }
  });
}
// 3. Variantenhandling (Größe/Einheit)
let productVariant = await prisma.productVariant.findFirst({/* ... */});
if (!productVariant) {
   productVariant = await prisma.productVariant.create({/* ... */});
}
\end{lstlisting}

\subsection{Kategorizierung: Automatisierte Einordnung via Pattern-Matching}

Ein weiteres wichtiges Element: Produkte werden mithilfe von Mustererkennung im Produktnamen \textbf{vollständig automatisiert kategorisiert}. Hierzu ist ein flexibles System entwickelt, bei dem zu jeder Kategorie eine Liste von typischen Schlüsselbegriffen gepflegt wird (z.B. "`milch"', "`joghurt"', "`kaffee"'), die als Pattern (inklusive Substrings) auf den normalisierten Produktnamen angewendet werden. So ist sichergestellt, dass alle Produkte marktplatzübergreifend nach gleichem Regelwerk einsortiert werden.

\begin{lstlisting}[style=typescriptstyle, caption={Beispielstruktur: Kategorie-Definitionen als JSON}]
{
  "category": "Milchprodukte",
  "patterns": ["milch", "joghurt", "skyr", "kefir", "kondensmilch"]
}
\end{lstlisting}

\emph{Bei jedem Import:} Es wird eine Liste aller passender Kategorien gesammelt und die Zuordnung in einer Many-to-many-Tabelle persistiert.

\subsection{Fazit: Garantierte Datenkonsistenz für Marktvergleich}

Dank der konsequenten Normalisierung, intelligenter Matching-Strategien und paralleler Datenbanklogik entsteht ein zentrales Produktschema, das alle Markt-Angebote, Varianten, Marken und Kategorien zuverlässig verbindet. Damit steht eine valide, vergleichbare und stets aktuelle Produktbasis für die App zur Verfügung.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACKEND-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Backend-Architektur und API-Design}
\renewcommand{\authorinitials}{MT}
\label{chap:backend}

\section{Backend-Aufbau und Signalverarbeitung}

Das Backend der Smart Shopping App basiert auf einer modernen Express.js-Architektur mit TypeScript und folgt dem bewährten Controller-Service-Pattern. Die Anwendung ist in mehrere Schichten unterteilt, um eine klare Trennung der Verantwortlichkeiten zu gewährleisten.

\subsection{Express.js App-Struktur}

Die Hauptanwendung wird in \texttt{app.ts} konfiguriert und folgt einer Middleware-Pipeline-Architektur:

\begin{lstlisting}[style=typescriptstyle,caption={Express.js App-Konfiguration}]
import express from "express";
import dotenv from "dotenv";
import cors from "cors";
import apiRoutes from "@/routes";
import errorHandler from "@/middleware/errorHandler";
import { clerkMiddleware } from "@clerk/express";
import { requireAuth }  from "@/lib/auth";

dotenv.config();

const app = express();

app.use(express.json());
app.use(cors());
app.use(clerkMiddleware());

app.use("/api", requireAuth(), apiRoutes);

app.use(errorHandler);

export default app;
\end{lstlisting}

Die Middleware-Pipeline verarbeitet Requests in folgender Reihenfolge:
\begin{enumerate}
    \item \textbf{JSON-Parsing:} Automatische Deserialisierung von JSON-Requests
    \item \textbf{CORS:} Cross-Origin Resource Sharing für Frontend-Kommunikation
    \item \textbf{Clerk Middleware:} Authentifizierung und User-Management
    \item \textbf{Auth Guard:} Zusätzliche Authentifizierungsprüfung
    \item \textbf{API Routes:} Routing zu spezifischen Endpunkten
    \item \textbf{Error Handler:} Zentrale Fehlerbehandlung
\end{enumerate}

\subsection{Authentifizierung mit Clerk}

Die Authentifizierung erfolgt über Clerk, einem Identity-as-a-Service-Provider. Jeder API-Request muss einen gültigen Bearer-Token im Authorization-Header enthalten:

\begin{lstlisting}[style=typescriptstyle,caption={Authentifizierungs-Middleware}]
export const requireAuth = () => (
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) => {
  const { userId } = getAuth(req);

  if (!userId) {
    res.status(401).json({
      error: "Unauthorized",
      message: "Authentication required",
    });
    return;
  }

  next();
};
\end{lstlisting}

Die \texttt{getAuth(req)}-Funktion extrahiert automatisch die User-ID aus dem JWT-Token, die dann in Controllern für user-spezifische Operationen verwendet wird.

\subsection{Error Handling und Middleware}

Das Backend implementiert ein zentrales Error-Handling-System, das verschiedene Fehlertypen unterschiedlich behandelt:

\begin{lstlisting}[style=typescriptstyle,caption={Zentraler Error Handler}]
export default function errorHandler(
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  console.error(err);
  if (typeof err.message === "string" && err.message.startsWith("DB_ERROR")) {
    res.status(500).json({ error: err.message });
    return;
  }
  res.status(err.status || 500).json({ error: err.message || "Unknown Error" });
}
\end{lstlisting}

Datenbankfehler werden speziell behandelt und mit dem Präfix "DB\_ERROR" gekennzeichnet, während andere Fehler mit einem generischen 500-Status beantwortet werden.

\subsection{Request/Response-Flow}

Der typische Request-Flow durchläuft folgende Schichten:

\begin{enumerate}
    \item \textbf{Route Layer:} Definiert HTTP-Endpunkte und HTTP-Methoden
    \item \textbf{Controller Layer:} Extrahiert Request-Daten und delegiert an Services
    \item \textbf{Service Layer:} Implementiert Business Logic und Datenbankoperationen
    \item \textbf{Database Layer:} Prisma ORM für typsichere Datenbankzugriffe
\end{enumerate}

\section{API-Design und Endpunkte}

Die API folgt RESTful-Prinzipien und ist in logische Ressourcen-Gruppen unterteilt. Jeder Endpunkt ist typgesichert und implementiert konsistente Response-Formate.

\subsection{Routing-Struktur}

Die API-Routen sind modular organisiert und werden über einen zentralen Router verwaltet:

\begin{lstlisting}[style=typescriptstyle,caption={Zentraler API-Router}]
import { Router } from "express";
import productsRouter from "./products";
import shoppingListRouter from "./shoppingLists";
import storesRouter from "./stores";

const api = Router();

api.use("/products", productsRouter);
api.use("/shoppinglist", shoppingListRouter);
api.use("/stores", storesRouter);

export default api;
\end{lstlisting}

\subsection{Controller-Service-Pattern}

Das Backend implementiert das Controller-Service-Pattern für eine klare Trennung zwischen HTTP-Logik und Business Logic:

\begin{lstlisting}[style=typescriptstyle,caption={Controller-Beispiel: Shopping List}]
export const addItemToShoppingList = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const { userId } = getAuth(req);
  const shoppingList = await service.addItemToShoppingList(
    userId as string,
    Number(req.body.variantId),
    Number(req.body.quantity)
  );
  res.json(shoppingList);
};
\end{lstlisting}

Controller sind für Request/Response-Handling zuständig, während Services die eigentliche Business Logic implementieren.

\subsection{API-Dokumentation}

\subsubsection{Shopping List Endpoints}

\textbf{POST /api/shoppinglist/}
\begin{itemize}
    \item \textbf{Description:} Erstellt eine neue Einkaufsliste für den authentifizierten Benutzer
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Request Body:} Keine
    \item \textbf{Response:} 
    \begin{lstlisting}[language=JSON]
{
  "id": 1,
  "name": "Default List",
  "userId": "user_123",
  "createdAt": "2024-01-15T10:30:00Z"
}
    \end{lstlisting}
\end{itemize}

\textbf{GET /api/shoppinglist/}
\begin{itemize}
    \item \textbf{Description:} Ruft die aktuelle Einkaufsliste des Benutzers ab
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Response:} 
    \begin{lstlisting}[language=JSON]
{
  "id": 1,
  "name": "Default List",
  "items": [
    {
      "id": 1,
      "variantId": 5,
      "quantity": 2,
      "variant": {
        "product": {
          "name": "Bio Milch",
          "brand": { "name": "GUT BIO" }
        }
      }
    }
  ]
}
    \end{lstlisting}
\end{itemize}

\textbf{PUT /api/shoppinglist/}
\begin{itemize}
    \item \textbf{Description:} Fügt ein Produkt zur Einkaufsliste hinzu
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Request Body:}
    \begin{lstlisting}[language=JSON]
{
  "variantId": 5,
  "quantity": 2
}
    \end{lstlisting}
    \item \textbf{Response:} Aktualisierte Einkaufsliste
\end{itemize}

\textbf{DELETE /api/shoppinglist/}
\begin{itemize}
    \item \textbf{Description:} Entfernt ein Produkt aus der Einkaufsliste
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Request Body:}
    \begin{lstlisting}[language=JSON]
{
  "variantId": 5
}
    \end{lstlisting}
\end{itemize}

\textbf{GET /api/shoppinglist/items}
\begin{itemize}
    \item \textbf{Description:} Ruft alle Einkaufslisten-Items mit Produktdetails ab
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Response:}
    \begin{lstlisting}[language=JSON]
[
  {
    "id": 1,
    "variantId": 5,
    "quantity": 2,
    "size": "1",
    "unit": "l",
    "name": "Bio Milch",
    "price": 1.29,
    "storeName": "Aldi Süd",
    "brandName": "GUT BIO",
    "imageUrl": "https://example.com/milk.jpg"
  }
]
    \end{lstlisting}
\end{itemize}

\subsubsection{Products Endpoints}

\textbf{GET /api/products}
\begin{itemize}
    \item \textbf{Description:} Ruft Produkte mit optionalen Filtern ab
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Query Parameters:}
    \begin{itemize}
        \item \texttt{search}: Suchbegriff für Produktname
        \item \texttt{category}: Kategorie-Filter
        \item \texttt{store}: Store-Filter
        \item \texttt{limit}: Maximale Anzahl Ergebnisse (Default: 50)
        \item \texttt{offset}: Offset für Pagination
    \end{itemize}
    \item \textbf{Response:}
    \begin{lstlisting}[language=JSON]
{
  "products": [
    {
      "id": 1,
      "name": "Bio Milch",
      "brand": { "name": "GUT BIO" },
      "variants": [
        {
          "id": 5,
          "size": "1",
          "unit": "l",
          "storeOffers": [
            {
              "price": 1.29,
              "store": { "name": "Aldi Süd" }
            }
          ]
        }
      ]
    }
  ],
  "total": 150,
  "limit": 50,
  "offset": 0
}
    \end{lstlisting}
\end{itemize}

\subsubsection{Stores Endpoints}

\textbf{GET /api/stores}
\begin{itemize}
    \item \textbf{Description:} Ruft alle verfügbaren Stores ab
    \item \textbf{Authentication:} Required (Bearer Token)
    \item \textbf{Response:}
    \begin{lstlisting}[language=JSON]
[
  {
    "id": 1,
    "name": "Aldi Süd",
    "color": "#4B946A"
  },
  {
    "id": 2,
    "name": "Aldi Nord", 
    "color": "#E74C3C"
  }
]
    \end{lstlisting}
\end{itemize}

\section{Datenbankintegration}

\subsection{Prisma ORM und Datenbankzugriff}

Das Backend nutzt Prisma als TypeScript-first ORM für typsichere Datenbankoperationen. Die Datenbankverbindung wird über einen zentralen Client verwaltet:

\begin{lstlisting}[style=typescriptstyle,caption={Datenbankverbindung}]
import { PrismaClient } from "@prisma/client";

export const db = new PrismaClient();
\end{lstlisting}

\subsection{Service-Layer und Business Logic}

Services implementieren die Business Logic und abstrahieren komplexe Datenbankoperationen. Ein typisches Beispiel ist der ShoppingListService:

\begin{lstlisting}[style=typescriptstyle,caption={Service-Layer Beispiel}]
export const getShoppingListItems = async (userId: string) => {
  const shoppingList = await db.shoppingList.findFirst({
    where: { userId: userId },
    include: {
      items: {
        include: {
          variant: {
            include: {
              product: {
                include: {
                  brand: true,
                },
              },
              storeOffers: {
                include: {
                  store: true,
                },
              },
              images: true,
            },
          },
        },
      },
    },
  });

  if (!shoppingList) {
    return null;
  }

  // Aggregation von Duplikaten
  const shopitems = shoppingList.items.reduce(
    (acc: typeof shoppingList.items, item) => {
      const existingItem = acc.find((i) => i.variantId === item.variantId);
      if (existingItem) {
        existingItem.quantity = existingItem.quantity + item.quantity;
      } else {
        acc.push(item);
      }
      return acc;
    },
    [] as typeof shoppingList.items
  );

  return shopitems.map((item) => ({
    id: item.variant?.product?.id,
    variantId: item.variantId,
    quantity: item.quantity,
    size: item.variant?.size,
    unit: item.variant?.unit,
    name: item.variant?.product?.name,
    price: item.variant?.storeOffers[0]?.price,
    storeName: item.variant?.storeOffers[0]?.store?.name,
    brandName: item.variant?.product?.brand?.name,
    imageUrl: item.variant?.images[0]?.sourceUrl,
  }));
};
\end{lstlisting}

\subsection{Transaktionsmanagement}

Für kritische Operationen werden Datenbanktransaktionen verwendet, um Datenkonsistenz zu gewährleisten.

\subsection{Datenbankschema}

% TODO: Datenbankschema-Beschreibung hier einfügen

\section{Performance und Skalierung}

\subsection{Optimierungen}

Das Backend implementiert mehrere Performance-Optimierungen:

\begin{itemize}
    \item \textbf{Eager Loading:} Prisma's \texttt{include} für optimierte Datenbankabfragen
    \item \textbf{Connection Pooling:} Automatisches Connection Management durch Prisma
    \item \textbf{Query Optimization:} Selektive Feldauswahl und Index-Nutzung
\end{itemize}

\subsection{Skalierungsaspekte}

\begin{itemize}
    \item \textbf{Horizontal Scaling:} Stateless-Architektur ermöglicht Load Balancing
    \item \textbf{Database Scaling:} PostgreSQL mit Read-Replicas für hohe Last
    \item \textbf{Caching:} Redis-Integration für häufig abgerufene Daten
\end{itemize}

\section{Sicherheitsaspekte}

\subsection{Authentifizierung und Autorisierung}

\begin{itemize}
    \item \textbf{JWT-Token-Validierung:} Clerk übernimmt sichere Token-Verwaltung
    \item \textbf{User-Isolation:} Alle Datenzugriffe sind user-spezifisch
    \item \textbf{Session-Management:} Automatische Token-Erneuerung und -Revokation
\end{itemize}

\subsection{Input-Validierung}

\begin{itemize}
    \item \textbf{TypeScript-Typisierung:} Compile-time Validierung
    \item \textbf{Express-Validierung:} Request-Body-Validierung
    \item \textbf{SQL-Injection-Schutz:} Prisma ORM verhindert SQL-Injection
\end{itemize}

\subsection{Weitere Sicherheitsmaßnahmen}

\begin{itemize}
    \item \textbf{CORS-Konfiguration:} Restriktive Cross-Origin-Policies
    \item \textbf{Error-Handling:} Keine sensiblen Informationen in Error-Responses
    \item \textbf{Rate Limiting:} Schutz vor DDoS-Angriffen (geplant)
    \item \textbf{HTTPS:} Erzwungene TLS-Verschlüsselung
\end{itemize}

\section{Deployment und DevOps}

\subsection{Umgebungskonfiguration}

Das Backend nutzt Umgebungsvariablen für Konfiguration:

\begin{lstlisting}[language=bash,caption={Umgebungsvariablen}]
# Datenbank
DATABASE_URL="postgresql://user:password@localhost:5432/shopping_app"

# Clerk Authentication
CLERK_SECRET_KEY="sk_test_..."
CLERK_PUBLISHABLE_KEY="pk_test_..."

# Server
PORT=3001
NODE_ENV=production
\end{lstlisting}

\subsection{Build und Deployment}

\begin{lstlisting}[language=json,caption={Package.json Scripts}]
{
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "jest"
  }
}
\end{lstlisting}

\subsection{CI/CD-Pipeline}

\begin{itemize}
    \item \textbf{Automated Testing:} Jest-Tests bei jedem Commit
    \item \textbf{Type Checking:} TypeScript-Compilation
    \item \textbf{Database Migrations:} Automatische Schema-Updates
    \item \textbf{Deployment:} Automatisierte Deployments nach erfolgreichen Tests
\end{itemize}

\section{Integration Tests}

\subsection{Test-Setup und Framework}

Das Backend verwendet Jest als Test-Framework mit Supertest für HTTP-API-Tests:

\begin{lstlisting}[style=typescriptstyle,caption={Jest-Konfiguration}]
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.test.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};

export default config;
\end{lstlisting}

\subsection{Authentifizierungstests}

Die Authentifizierung wird umfassend getestet:

\begin{lstlisting}[style=typescriptstyle,caption={Auth-Tests}]
import request from "supertest";
import app from "../app";

jest.mock("@clerk/express");

describe("Auth Header Middleware", () => {
  it("should return 401 if no auth header is sent", async () => {
    const res = await request(app).get("/api/shoppinglist/items");
    expect(res.status).toBe(401);
    expect(res.body).toHaveProperty("error");
  });

  it("should return 401 if invalid auth header is sent", async () => {
    const res = await request(app)
      .get("/api/shoppinglist/items")
      .set("Authorization", "Bearer invalid-token");
    expect(res.status).toBe(401);
    expect(res.body).toHaveProperty("error");
  });

  it("should return 200 if a valid auth header is sent", async () => {
    const res = await request(app)
      .get("/api/shoppinglist/items")
      .set("Authorization", "Bearer valid-token");
    expect(res.status).toBe(200);
  });
});
\end{lstlisting}

\subsection{Shopping List Integration Tests}

Die Shopping List Funktionalität wird mit umfassenden Integration Tests abgedeckt:

\begin{lstlisting}[style=typescriptstyle,caption={Shopping List Integration Tests}]
import request from "supertest";
import app from "../app";
import { db } from "../lib/db";

describe("ShoppingList Integration", () => {
  beforeAll(async () => {
    // Clean up test database
    await db.shoppingList.deleteMany({ where: { userId: "test-user-id" } });
  });

  let createdList: any;

  it("should create a shopping list", async () => {
    const res = await request(app)
      .post("/api/shoppinglist/")
      .set("Authorization", "Bearer valid-token")
      .send({ name: "IntegrationTestListe" });
    expect(res.status).toBe(200);
    expect(res.body).toHaveProperty("id");
    createdList = res.body;
  });

  it("should get the created shopping list", async () => {
    const res = await request(app)
      .get("/api/shoppinglist")
      .set("Authorization", "Bearer valid-token");
    expect(res.status).toBe(200);
    expect(res.body).toHaveProperty("id", createdList.id);
  });
  
  it("should add an item to the shopping list", async () => {
    const res = await request(app)
      .put("/api/shoppinglist/")
      .set("Authorization", "Bearer valid-token")
      .send({ variantId: 1, quantity: 1 });
    expect(res.status).toBe(200);
  });

  it("should return 400 if a null value is sent for variantId", async () => {
    const res = await request(app)
      .put("/api/shoppinglist/")
      .set("Authorization", "Bearer valid-token")
      .send({ variantId: null, quantity: 1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty("error");
  });

  it("should return 404 when trying to add item with non-existent variantId", async () => {
    const res = await request(app)
      .put("/api/shoppinglist/")
      .set("Authorization", "Bearer valid-token")
      .send({ variantId: 999999999, quantity: 1 });
    expect(res.status).toBe(404);
    expect(res.body).toHaveProperty("error");
  });

  it("should return 400 if quantity is negative", async () => {
    const res = await request(app)
      .put("/api/shoppinglist/")
      .set("Authorization", "Bearer valid-token")
      .send({ variantId: 1, quantity: -1 });
    expect(res.status).toBe(400);
    expect(res.body).toHaveProperty("error");
  });
});
\end{lstlisting}

Diese Tests decken die wichtigsten Szenarien ab:
\begin{itemize}
    \item \textbf{CRUD-Operationen:} Erstellen, Abrufen, Hinzufügen von Items
    \item \textbf{Validierung:} Null-Werte, negative Mengen, nicht-existierende IDs
    \item \textbf{Error Handling:} Korrekte HTTP-Status-Codes und Error-Responses
    \item \textbf{Authentifizierung:} Alle Tests verwenden gültige Bearer-Tokens
\end{itemize}

\subsection{Mocking-Strategien}

\begin{itemize}
    \item \textbf{Clerk-Mocking:} Mock der Clerk-Authentifizierung für Tests
    \item \textbf{Datenbank-Mocking:} Prisma-Client-Mocking für isolierte Tests
    \item \textbf{External Services:} Mock von externen API-Calls
\end{itemize}

\subsection{Test-Ausführung}

\begin{lstlisting}[language=bash,caption={Test-Befehle}]
# Alle Tests ausführen
npm test

# Tests im Watch-Modus
npm test -- --watch

# Spezifische Test-Datei
npm test -- authHeader.test.ts
npm test -- shoppingList.test.ts
\end{lstlisting}

\subsection{Ausblick: Erweiterte Tests}

Für eine vollständige Testabdeckung könnten folgende Tests implementiert werden:

\begin{itemize}
    \item \textbf{Products API Tests:} Vollständige CRUD-Operationen für Produkte
    \item \textbf{Stores API Tests:} Store-Management und -Abruf
    \item \textbf{Business Logic Tests:} Service-Layer-Tests mit Mock-Datenbank
    \item \textbf{Error Handling Tests:} Validierung von Fehlerbehandlung
    \item \textbf{Performance Tests:} Load-Testing für kritische Endpunkte
    \item \textbf{End-to-End Tests:} Vollständige Workflows mit echter Datenbank
\end{itemize}

\section{Zusammenfassung}

Das Backend der Smart Shopping App implementiert eine moderne, skalierbare Architektur mit Express.js, TypeScript und Prisma. Die API folgt RESTful-Prinzipien und bietet eine vollständige Authentifizierung über Clerk. Durch das Controller-Service-Pattern wird eine klare Trennung der Verantwortlichkeiten gewährleistet, während umfassende Tests die Codequalität sicherstellen.

Die Architektur ist darauf ausgelegt, zukünftige Erweiterungen wie Caching, Rate Limiting und erweiterte Sicherheitsfeatures einfach zu integrieren.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DB-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Datenbankarchitektur und -entwicklung}
\renewcommand{\authorinitials}{MK}

\section{Einleitung}

Die Datenbank bildet das zentrale Fundament der Smart Shopping App, da sämtliche Produkt-, Listen- und Preisdaten effizient, sicher und flexibel gespeichert, abgerufen und miteinander verknüpft werden müssen. Die gewählte Architektur und das technologische Vorgehen haben maßgeblichen Einfluss auf Wartbarkeit, Erweiterbarkeit sowie die reibungslose Zusammenarbeit mit anderen Systemkomponenten – insbesondere bei modernen KI-gestützten Use Cases.

\section{Entwicklungsschritte und Migrationshintergrund}

Zu Projektbeginn wurde eine initiale, manuell aufgesetzte PostgreSQL-Datenbank bei Supabase verwendet. Supabase überzeugte durch eine schnelle Inbetriebnahme, webbasierte Oberfläche und REST-Schnittstellen, mit denen Entwickler sofort experimentieren konnten. Die Tabellen und Beziehungen wurden direkt im Supabase-Interface angelegt, was für den Proof-of-Concept und frühe Entwicklungsschritte ausreichend war.

Im Laufe des Projektes stiegen jedoch die Anforderungen: Mit wachsender Komplexität der Domäne, einer Vielzahl an Entitäten (Produkte, Varianten, Einkaufsliste, Angebote, Präferenzen usw.) und der Notwendigkeit häufiger Schemaänderungen zeigte sich, dass ein effizientes und modernes ORM-Framework notwendig ist. Die Wahl fiel auf den Einsatz von \textbf{Prisma} als ORM-Schicht, verbunden mit einer „klassischen“ PostgreSQL-Datenbank. Prisma erlaubt es, das Datenbankschema deklarativ in einer Versionierungsdatei (\texttt{schema.prisma}) zu pflegen, Migrationsprozesse sauber zu steuern und sämtliche Entitäten im Backend-Typen sicher und komfortabel zu verwalten.

\section{Gründe für die Migration auf Prisma \& klassische PostgreSQL-Instanz}

\begin{itemize}
    \item \textbf{Flexibilität und Wartbarkeit:} Schematische Änderungen – wie neue Felder, Tabellen, Relationen – können deklarativ vorgenommen und per Migration automatisch angewendet werden, ohne manuell Felder nachzupflegen.
    \item \textbf{Typisierung und Entwicklerfreundlichkeit:} Prisma generiert Typsicherungen und Methoden für alle Modelle, was bereits zur Entwicklungszeit Fehler reduziert und die Produktivität steigert.
    \item \textbf{Effizienz bei komplexen Entitäten:} Viele-zu-Viele- und verschachtelte Relationen (Produkte/Varianten, Kategorien, Präferenzen) werden elegant abgebildet und performant gemanagt.
    \item \textbf{KI-Integration:} Besonders für KI-Anwendungen ist es von Vorteil, das exakte Datenbankschema als Kontext bereitstellen zu können. Damit lassen sich automatisierte Abfragen, Generierung von Datenbankcode oder intelligente Schnittstellen viel einfacher umsetzen, da das Schema maschinenlesbar und selbstdokumentierend ist.
    \item \textbf{Teamwork und Automatisierbarkeit:} Dank Versionierung und automatischer Migration bleibt das Datenmodell im gesamten Team (und allen Umgebungen) konsistent.
\end{itemize}

\section{Struktur und Sinn der Datenbank für den Use Case}

Die folgende grafische Übersicht zeigt die wichtigsten Tabellen, Relationen und Primärschlüssel der finalen Datenbankstruktur, wie sie mit Prisma modelliert und als PostgreSQL-Datenbank betrieben wird:

% --- Bild/Diagramm einfügen ---
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.98\textwidth]{media/supabase-schema-vgqtxqfvygduzmuwlmba.png}
    \caption{Schematische Übersicht der Projekt-Datenbank (als Supabase-Tabellenmodell)}
    \label{fig:db-schema}
\end{figure}

Die Datenbank vereint folgende Schlüsselaspekte unseres Use Cases:
\begin{itemize}
    \item \textbf{Produktspeicher:} Tabelle \texttt{products} enthält alle eindeutig erkannten Artikel (z.B. „Nutella 750g“), mit Zuordnung zur Marke, logischen Kategorien und beliebig vielen Varianten (\texttt{product\_variants} für Größen, Verpackungseinheiten etc.).
    \item \textbf{Marktübergreifender Vergleich:} Über \texttt{store\_offers} erhält jede Variante je Markt einen eigenen Preissatz – so kann die App tagesaktuell berechnen, welcher Supermarkt für die komplette Einkaufsliste der günstigste ist.
    \item \textbf{Einkaufslistenfunktion:} \texttt{shopping\_lists} und \texttt{shopping\_list\_items} Schnittstellen ermöglichen, nutzerbasierte Listen anzulegen und darin beliebige Produktvarianten in entsprechender Menge zu speichern. So bleibt die Architektur flexibel und beliebig skalierbar.
    \item \textbf{User-Zentrierung:} \texttt{UserId} bei Listen, Präferenzen (\texttt{preferences}), Favoriten, etc. koppelt alle Interaktionen eindeutig an das Anmelde-/Auth-System.
    \item \textbf{Angebots- und Preishistorie:} Über Felder wie \texttt{valid\_from}, \texttt{valid\_to} und \texttt{last\_updated} lassen sich jederzeit Angebotszeitpunkte oder Preisentwicklungen nachvollziehen.
    \item \textbf{Produktbilder und Metadaten:} Die Tabelle \texttt{product\_images} referenziert extern gespeicherte Bilder und bietet so für KI-basierte Such- oder Bilderkennungsideen einen klaren Ankerpunkt.
    \item \textbf{Erweiterbarkeit:} Zusätzliche Features (z.B. Präferenzen, Archiv, Benutzerfavoriten) können einfach durch weitere Tabellen oder Relationen ergänzt werden.
\end{itemize}

\section{Fazit}

Die konsequente Migration auf eine Prisma-verwaltete PostgreSQL-Datenbank erwies sich als zentraler Schritt zu einer robusten, flexiblen und wartungsfreundlichen Backend-Architektur. Für die Anforderungen einer KI-gestützten Smart Shopping App ist dieser Ansatz unverzichtbar: Das exakte, maschinenlesbare Datenmodell ist für Integration, automatisierte Weiterverarbeitung und Entwicklung innovativer Backend- bzw. KI-Features essenziell. Gleichzeitig garantiert die gewählte Architektur Zukunftssicherheit und einfache Erweiterbarkeit für neue Funktionen und Use Cases.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UI-KAPITEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Benutzeroberfläche (UI)}
\renewcommand{\authorinitials}{NK}
\label{chap:ui}

\section{Einleitung}
Die Benutzeroberfläche stellt die Verbindung zwischen Nutzer:innen und den technischen Funktionalitäten der Smart Shopping App her. Sie spielt eine zentrale Rolle bei der täglichen Nutzung der App, da sie das Hinzufügen von Produkten zur Einkaufsliste, das Anzeigen und Bearbeiten der Listen sowie die Darstellung der Preisinformationen und Marktvergleiche ermöglicht.

\section{Grundlegende Anforderungen an die UI}
\begin{itemize}
    \item \textbf{Intuitive Bedienbarkeit:} Die Navigation und Bedienung der App soll für alle Nutzer:innen verständlich und schnell erlernbar sein.
    \item \textbf{Responsives Design:} Die Oberfläche adaptiert sich auf unterschiedliche Bildschirmgrößen (Smartphone, Tablet, Desktop).
    \item \textbf{Echtzeit-Feedback:} Preisvergleiche und Marktvorschläge sollen unmittelbar nach Eingabe oder Änderung der Einkaufsliste angezeigt werden.
    \item \textbf{Modulare Architektur:} Die UI ist so konzipiert, dass sie sich um weitere Features (z.B. zusätzliche Märkte oder Angebotsfunktionen) erweitern lässt.
\end{itemize}

\section{Mockups und zentrale Ansichten}
% Hier können später Skizzen/Mobile Screenshots oder Diagramme eingefügt werden.
% Beispiel (mit Platzhalter):
\begin{figure}[h!]
    \centering
    \fbox{
        \parbox{0.85\textwidth}{
            \vspace{3cm}
            \begin{center}
                \textbf{Abb. 1: Mockup Startansicht der App}\\
                \emph{(Platzhalter für spätere Screenshots oder Entwürfe)}
            \end{center}
            \vspace{3cm}
        }
    }
    \caption{Mockup: Hauptansicht der Smart Shopping App}
    \label{fig:ui_mockup}
\end{figure}

\section{Beschreibung zentraler UI-Elemente}
\begin{enumerate}
    \item \textbf{Einkaufsliste:} Übersicht über die gewählten Produkte, Mengenanpassung, Möglichkeit zum Abhaken gekaufter Artikel.
    \item \textbf{Marktvergleichsübersicht:} Darstellung, bei welchem Markt die aktuelle Liste am günstigsten ist und Übersicht über Einzelpreise.
    \item \textbf{Produktsuche/Autocomplete:} Komfortable Suche mit Vorschlägen, um das Hinzufügen neuer Produkte zu beschleunigen.
    \item \textbf{Detailsicht:} Zeigt weitere Informationen zum Produkt (z.B. Angaben aus Scraping/Enrichment) oder Angebotspreise.
    \item \textbf{Nutzerprofil- und Einstellungen:} (z.B. bevorzugte Märkte, Filteroptionen)
\end{enumerate}

\section{Geplante Weiterentwicklungen}
% Hier können noch weitere Features oder Ideen wie Barcode-Scanner, ortsbasierte Marktempfehlungen etc. ergänzt werden.

\section{Home-Screen}
\label{sec:home_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Screen dient als zentrale Übersicht für die Einkaufsliste des Nutzers. Hier kann der Nutzer:
\begin{itemize}
    \item Seine aktuelle Einkaufsliste einsehen
    \item Einzelne Produkte aus der Liste entfernen
    \item Die gesamte Liste archivieren
    \item Eine neue Einkaufsliste anlegen, falls noch keine existiert
    \item Den Gesamtpreis der Liste sehen
    \item Zur Detailansicht der Liste wechseln
\end{itemize}

\subsubsection{UI/UX-Beschreibung}

\textbf{Wichtige UI-Elemente:}
\begin{itemize}
    \item \textbf{TopBar:} Navigationsleiste am oberen Rand
    \item \textbf{ScrollView:} Zeigt die Einkaufsliste als scrollbare Kartenansicht
    \item \textbf{Card-Komponenten:} Jede Karte repräsentiert ein Produkt mit Name, Marke, Menge, Preis, Bild und Lösch-Button
    \item \textbf{ButtonSquare:} Button zum Wechsel in die Detailansicht der Liste
    \item \textbf{Floating View:} Zeigt den Gesamtpreis der Liste an
    \item \textbf{"Create Shopping List"-Button:} Erscheint, wenn noch keine Liste existiert
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
\begin{itemize}
    \item Produkt löschen: Über den Lösch-Button auf jeder Produktkarte
    \item Einkaufsliste archivieren: Über einen Button (nicht im Ausschnitt, aber im Code vorgesehen)
    \item Neue Liste anlegen: Über den "Create Shopping List"-Button
    \item Zur Detailansicht wechseln: Über den Button mit Einkaufswagen-Icon
\end{itemize}

\subsubsection{User Flow}

\textbf{Von welchem Screen kommt der Nutzer hierher?}
Meistens über die Tab-Navigation als Startscreen oder nach dem Login.

\noindent\textbf{Wohin geht es von hier aus?}
\begin{itemize}
    \item Zur Detailansicht der Einkaufsliste (/listDetails)
    \item Zu Produktdetails (über die Produktkarte, falls implementiert)
    \item Archivieren oder neue Liste anlegen
\end{itemize}

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Komponenten:}
\begin{itemize}
    \item ListScreen (Hauptkomponente)
    \item TopBar (Navigationsleiste)
    \item Card (Produktkarte)
    \item ButtonSquare (Floating Action Button)
    \item LoadingSpinner (Ladeanzeige)
\end{itemize}

\noindent\textbf{State Management:}
\begin{itemize}
    \item React State (useState, useEffect, useCallback)
    \item Kontext: useProductContext für Produktdaten und Ladezustand
\end{itemize}

\noindent\textbf{Services/APIs:}
api-Service für alle Backend-Requests (z.B. getShoppingListItems, createShoppingList, deleteFromShoppingList, archiveShoppingList)

\subsubsection{Wichtige Funktionen/Methoden}
\begin{itemize}
    \item \textbf{loadList:} Lädt die aktuelle Einkaufsliste und prüft, ob eine existiert.
    \item \textbf{handleCreateShoppingList:} Erstellt eine neue Einkaufsliste via API.
    \item \textbf{handleDelete:} Löscht ein Produkt aus der Liste.
    \item \textbf{handleArchiveList:} Archiviert die aktuelle Liste.
    \item \textbf{calculateTotal:} Berechnet den Gesamtpreis der Einkaufsliste.
    \item \textbf{Scroll-Handling:} Zeigt/Versteckt Floating Buttons je nach Scrollposition (Performance-Optimierung mit react-native-reanimated).
\end{itemize}

\subsubsection{Besondere Herausforderungen}
\begin{itemize}
    \item \textbf{Performance-Optimierung:} Floating Buttons werden mit Reanimated animiert, um ein flüssiges UI zu gewährleisten.
    \item \textbf{Fehlerbehandlung:} Umfangreiche Alerts und Fallbacks, falls API-Requests fehlschlagen.
    \item \textbf{User Experience:} Unterschiedliche UI-Zustände (keine Liste, leere Liste, gefüllte Liste) werden klar unterschieden und kommuniziert.
    \item \textbf{Synchronisation:} Die Liste wird bei jedem Fokus auf den Screen neu geladen (useFocusEffect), um immer aktuelle Daten zu zeigen.
\end{itemize}

\section{Explore-Screen}
\label{sec:explore_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Explore-Screen dient dazu, dem Nutzer eine Übersicht über Produktkategorien und verfügbare Supermärkte zu geben. Hier kann der Nutzer gezielt nach Produkten suchen, Kategorien durchstöbern oder Angebote von bestimmten Märkten anzeigen lassen.

\subsubsection{UI/UX-Beschreibung}

\textbf{Zentrale Elemente:}
\begin{itemize}
    \item Oben befindet sich eine Navigationsleiste (TopBar).
    \item Ein prominenter Button ('Add Products') ermöglicht die Produktsuche.
    \item Darunter werden die Lieblingskategorien ('Your Favourites') angezeigt.
    \item Es folgt eine Liste von Kategorien (z.B. Gemüse, Obst, Milch).
    \item Am unteren Ende werden verfügbare Stores (Supermärkte) als auswählbare Felder angezeigt, farblich hervorgehoben je nach Markt.
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
\begin{itemize}
    \item 'Add Products'-Button: Öffnet die Produktsuche.
    \item Kategorien und Stores: Antippbar, führen zu einer gefilterten Produktsuche.
\end{itemize}

\subsubsection{User Flow}

\textbf{Einstieg:} Der Nutzer gelangt meist von einem Tab-Menü oder der Hauptnavigation auf diesen Screen.

\noindent\textbf{Von hier aus kann der Nutzer:}
\begin{itemize}
    \item Über den "Add Products"-Button zur Produktsuche navigieren.
    \item Über eine Kategorie oder einen Store gezielt Produkte filtern und anzeigen lassen.
    \item Nach Auswahl wird der Nutzer zur Such-/Produktübersicht weitergeleitet.
\end{itemize}

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Hauptkomponente:} explore (React Functional Component)

\noindent\textbf{Eingesetzte Komponenten:}
\begin{itemize}
    \item TopBar (Navigation)
    \item SearchButton (Produktsuche)
    \item CategorieField (Favoriten)
    \item CategorieGroup (Kategorien \& Stores)
\end{itemize}

\noindent\textbf{Datenmodell:} Store-Typ aus den globalen Typen

\noindent\textbf{API:} Daten werden über api.getStores() geladen

\noindent\textbf{State Management:} React useState/useEffect (lokaler State)

\subsubsection{Wichtige Funktionen/Methoden}

\begin{itemize}
    \item \textbf{getStoreColor(name: string):} Weist jedem Store eine spezifische Farbe zu.
    \item \textbf{useEffect + fetchStores:} Lädt beim ersten Rendern die Store-Liste asynchron von der API und speichert sie im State.
    \item \textbf{Interaktive Elemente (onPress):} Navigieren mit router.push zur Suchseite, ggf. mit Store-Filter.
\end{itemize}

\subsubsection{Besondere Herausforderungen}
\begin{itemize}
    \item Dynamisches Laden und Anzeigen der Stores mit Farbcodierung.
    \item Fehlerbehandlung beim Laden der Stores (Alert bei Fehler).
    \item Übersichtliche und intuitive UI trotz vieler Auswahlmöglichkeiten.
\end{itemize}

\section{Search-Screen}
\label{sec:search_screen}

\subsection{Nutzerperspektive}

\subsubsection{Zweck des Screens}
Der Nutzer kann auf diesem Screen gezielt nach Produkten suchen, Filter anwenden (Kategorie, Store) und Produkte zur Einkaufsliste hinzufügen. Ziel ist es, schnell und komfortabel passende Angebote zu finden.

\subsubsection{UI/UX-Beschreibung}

\textbf{Zentrale Elemente:}
\begin{itemize}
    \item \textbf{Suchleiste:} Oben mittig, ermöglicht die Suche nach Produktnamen oder Marken.
    \item \textbf{Filter-Button:} Links neben der Suchleiste öffnet ein Modal für Filteroptionen (Kategorie, Store).
    \item \textbf{Cancel-Button:} Rechts neben der Suchleiste, löscht die aktuelle Suche.
    \item \textbf{Produktliste:} Zeigt gefilterte oder alle Produkte als Karten an, sortiert nach günstigstem Preis.
    \item \textbf{Produktkarte:} Enthält Produktdetails und einen Button (PlusCircle), um das Produkt zur Einkaufsliste hinzuzufügen.
    \item \textbf{Filter-Modal:} Ermöglicht Mehrfachauswahl von Kategorien und Stores, sowie das Zurücksetzen oder Anwenden der Filter.
    \item \textbf{Ladespinner:} Wird angezeigt, solange die Produktdaten geladen werden.
\end{itemize}

\noindent\textbf{Interaktive Elemente:}
\begin{itemize}
    \item Suchleiste (Textinput)
    \item Filter-Button (öffnet Modal)
    \item Cancel-Button (setzt Suche zurück)
    \item Produktkarten (klickbar, führen zu Detailansicht)
    \item PlusCircle-Button (fügt Produkt zur Liste hinzu)
    \item Filter-Modal mit MultiSelects und Buttons (Reset, Apply)
\end{itemize}

\subsubsection{User Flow}
\textbf{Einstieg:} Der Nutzer kommt meist von einem Tab (z.B. "Explore") oder durch Auswahl eines Stores.

\noindent\textbf{Aktionen:} Nutzer kann suchen, filtern, Produkte zur Liste hinzufügen oder Details aufrufen.

\noindent\textbf{Navigation:}
\begin{itemize}
    \item Klick auf ein Produkt → Detailansicht (/details/[id])
    \item Filter anwenden → aktualisierte Produktliste
    \item Zurück zu anderen Tabs oder Screens jederzeit möglich
\end{itemize}

\subsection{Technische Perspektive}

\subsubsection{Code-Architektur}

\textbf{Hauptkomponente:} SearchSite (funktionale React-Komponente)

\noindent\textbf{Verwendete Komponenten:}
\begin{itemize}
    \item SearchBar (benutzerdefinierte Suchleiste)
    \item CustomMultiSelect (Filterauswahl)
    \item SearchCard (Produktkarte)
    \item ButtonSizeable, ButtonTransparent (Buttons)
    \item LoadingSpinner (Ladesymbol)
\end{itemize}

\noindent\textbf{State Management:} React Context (useProductContext) für Produkte und Laden-Status

\noindent\textbf{API:} Zugriff auf Stores und Produkte über api-Service

\subsubsection{Abhängigkeiten}

\textbf{Services:} api (z.B. getStores, addToShoppingList)

\noindent\textbf{State:} Produkte, Stores, Filterauswahl, Suchbegriff, Ladezustand

\noindent\textbf{Libraries:} expo-router, @shopify/flash-list, lucide-react-native (Icons), React Native Komponenten

\subsubsection{Wichtige Funktionen/Methoden}
\begin{itemize}
    \item \textbf{handleSearch(query):} Filtert Produkte nach Suchbegriff und sortiert nach Preis.
    \item \textbf{applyFilters():} Wendet Suchbegriff, Kategorie- und Store-Filter an, sortiert Ergebnis.
    \item \textbf{fetchStores():} Holt Store-Daten von der API.
    \item \textbf{useEffect-Hooks:}
    \begin{itemize}
        \item Lädt Stores beim Mounten.
        \item Setzt Store-Filter, wenn ein Store-Name als Parameter übergeben wird.
        \item Lädt Produkte, falls noch nicht vorhanden.
        \item Wendet Filter automatisch an, wenn sich die Store-Auswahl ändert.
    \end{itemize}
    \item \textbf{renderItem:} Rendert einzelne Produktkarten mit Interaktionsmöglichkeiten.
\end{itemize}

\subsubsection{Besondere Herausforderungen}
\begin{itemize}
    \item \textbf{Filterlogik:} Kombination aus Suchbegriff, Kategorie- und Store-Filter, inklusive Sortierung.
    \item \textbf{Performance:} Nutzung von FlashList für performantes Rendering großer Produktlisten.
    \item \textbf{State-Synchronisation:} Automatisches Anwenden von Filtern bei Änderung der Auswahl, Synchronisation mit Context.
    \item \textbf{UX:} Reset- und Apply-Logik im Filter-Modal, sofortige Rückmeldung bei Suche und Filterung.
\end{itemize}

\section{UI-Komponenten}
\label{sec:ui_komponenten}

\subsection{Home(index)}

\subsubsection{ShoppingListItemCard}
Die Komponente ShoppingListItemCard stellt ein einzelnes Produkt in einer Einkaufsliste als interaktive Karte dar. Sie zeigt Produktinformationen und ermöglicht Swipe-Aktionen.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item Produktdaten wie Name, Marke, Preis, Menge, Einheit, Größe und Bild-URL.
    \item Optional: onPress für Klickaktionen, hasAButton für einen Aktions-Button, sowie renderRightActions und renderLeftActions für individuelle Swipe-Aktionen.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Die Karte ist abgerundet, hat einen Schatten und zeigt das Produktbild, Name, Marke, Preis und Mengenangaben.
    \item Das Bild wird links angezeigt, daneben die Produktdetails.
\end{itemize}

\textbf{Interaktivität:}
\begin{itemize}
    \item Die Karte ist mit Swipeable umgeben und unterstützt Swipe-Gesten nach rechts und links.
    \item Beim Swipen nach rechts kann ein Button oder eine benutzerdefinierte Aktion angezeigt werden.
    \item Die Karte kann optional per Klick ausgewählt werden.
\end{itemize}

\textbf{Fehlerbehandlung:}
\begin{itemize}
    \item Bildladefehler werden im Log ausgegeben.
\end{itemize}

\noindent\textbf{Verwendung:} ShoppingListItemCard eignet sich zur Darstellung von Produkten in einer Einkaufsliste mit Swipe- und Klickfunktionen, z.B. zum Löschen, Bearbeiten oder Auswählen eines Artikels. Sie ist flexibel und kann mit verschiedenen Aktionen erweitert werden.

\subsection{Explore}

\subsubsection{CategorieField}
Die Komponente CategorieField ist ein wiederverwendbares React Native-UI-Element, das eine Kategorie als anklickbares Feld darstellt. Sie nimmt folgende Props entgegen:
\begin{itemize}
    \item \textbf{title:} Der Name der Kategorie (wird als Text angezeigt).
    \item \textbf{image:} Optionales Bild, das dekorativ rechts oben im Feld angezeigt wird.
    \item \textbf{backgroundColor:} Optionaler Hintergrundfarbwert (Standard: "\#4B946A").
    \item \textbf{onPress:} Optionaler Callback, der beim Antippen des Feldes ausgeführt wird.
\end{itemize}

\noindent\textbf{Aufbau:}
\begin{itemize}
    \item Das Haupt-Element ist ein Pressable, das das gesamte Feld anklickbar macht.
    \item Im Feld wird der Titel als weißer, fetter Text oben links angezeigt.
    \item Falls ein Bild übergeben wird, erscheint es dekorativ rechts oben, leicht gedreht und abgerundet.
    \item Das Layout nutzt Tailwind-Klassen und Style-Props für responsives und modernes Design.
\end{itemize}

\noindent\textbf{Verwendung:} Die Komponente eignet sich, um Kategorien in einer Übersicht darzustellen, z.B. in einer Liste oder einem Grid. Sie kann individuell mit Titel, Bild und Farbe angepasst und mit einer Aktion beim Klick versehen werden.

\subsubsection{CategorieGroup}
Die Komponente CategorieGroup dient dazu, eine Gruppe von Kategorien als übersichtliche, responsive Felder darzustellen. Sie nimmt ein Array von Kategorien entgegen und ordnet diese in Reihen mit jeweils zwei Feldern an. Bei einer ungeraden Anzahl wird das erste Feld einzeln in einer eigenen Reihe angezeigt.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{categories:} Ein Array von Kategorie-Objekten mit Titel, Bild, Hintergrundfarbe und -optionaler Aktion.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick auf ein Feld ausgeführt wird und die jeweilige Kategorie übergibt.
\end{itemize}

\textbf{Logik:}
\begin{itemize}
    \item Prüft, ob Kategorien vorhanden sind.
    \item Bei ungerader Anzahl wird das erste Element einzeln angezeigt, die restlichen werden paarweise gruppiert.
    \item Jede Reihe wird als View mit zwei Feldern (CategorieField) dargestellt. Ist eine Reihe unvollständig, wird der Platz mit einem leeren Feld aufgefüllt.
\end{itemize}

\textbf{Layout:}
\begin{itemize}
    \item Nutzt Flexbox und Tailwind-Klassen für ein modernes, flexibles Design.
    \item Die Felder sind gleichmäßig verteilt und haben Abstände zwischen den Reihen.
\end{itemize}

\noindent\textbf{Verwendung:} CategorieGroup eignet sich, um Kategorien in einer übersichtlichen, klickbaren Grid-Ansicht darzustellen, z.B. auf einer Explore-Seite. Die Komponente ist flexibel und kann individuell mit Aktionen und Design-Optionen erweitert werden.

\subsubsection{SearchButton}
Die Komponente SearchButton ist ein klickbarer Button, der wie ein Suchfeld aussieht, aber kein Eingabefeld ist. Sie zeigt ein Lupen-Icon und einen beschrifteten Text (Standard: "Add Products") an.

\noindent\textbf{Aufbau:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{label:} Optionaler Text, der im Button angezeigt wird.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick ausgeführt wird.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Ein Pressable mit abgerundeten Ecken, weißem Hintergrund und grauem Rahmen.
    \item Das Lupen-Icon (Search aus lucide-react-native) steht links neben dem Text.
    \item Der Button reagiert visuell auf Druck (verringerte Opazität, Android Ripple-Effekt).
\end{itemize}

\noindent\textbf{Verwendung:} SearchButton eignet sich als auffälliger, interaktiver Button für Such- oder Hinzufügen-Aktionen, z.B. am oberen Rand einer Produktliste. Die Komponente ist einfach anpassbar und kann überall eingesetzt werden, wo ein solcher Button benötigt wird.

\subsection{Search}

\subsubsection{SearchBar}
Die Komponente SearchBar ist eine interaktive Suchleiste für React Native, die Benutzereingaben entgegennimmt und Suchanfragen auslöst.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{placeholder:} Optionaler Platzhaltertext im Eingabefeld (Standard: "Search...").
    \item \textbf{onSearch:} Callback, der bei jeder Änderung des Suchbegriffs aufgerufen wird.
\end{itemize}

\hangindent=2em
\hangafter=1
\textbf{Ref-API:}
Über das ref kann die Methode clear von außen aufgerufen werden, um das Suchfeld zu leeren und die Tastatur zu schließen.

\textbf{Logik:}
\begin{itemize}
    \item Die Eingabe wird im State query gespeichert.
    \item Jede Änderung im Textfeld ruft onSearch mit dem aktuellen Wert auf.
    \item Ein Klick auf die Leiste fokussiert das Eingabefeld.
    \item Die Methode clearSearch setzt das Feld zurück und schließt die Tastatur.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Die Suchleiste besteht aus einem weißen, abgerundeten Container mit einem TextInput.
    \item Das TextInput ist direkt fokussierbar und optisch schlicht gehalten.
\end{itemize}

\noindent\textbf{Verwendung:} SearchBar eignet sich für Suchfunktionen in Listen oder Übersichten. Sie kann von außen gesteuert werden (z.B. zum Zurücksetzen) und ist flexibel für verschiedene Anwendungsfälle einsetzbar.

\subsubsection{CustomMultiSelect}
Die Komponente CustomMultiSelect ist ein individuell gestaltetes Mehrfach-Auswahlfeld für React Native, basierend auf react-native-element-dropdown. Sie ermöglicht die Auswahl mehrerer Optionen aus einer Liste und bietet eine Suchfunktion.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{data:} Array von Auswahloptionen mit label und value.
    \item \textbf{labelField, valueField:} Feldnamen für Anzeige und Wert.
    \item \textbf{placeholder:} Platzhaltertext im Auswahlfeld.
    \item \textbf{value:} Array der aktuell ausgewählten Werte.
    \item \textbf{onChange:} Callback, der bei Änderung der Auswahl ausgelöst wird.
    \item Diverse Style-Props zur Anpassung des Designs.
    \item \textbf{search:} Aktiviert die Suchfunktion (Standard: true).
    \item \textbf{maxHeight:} Maximale Höhe der Dropdown-Liste.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Die Dropdown-Liste zeigt alle Optionen an, ausgewählte werden mit einem Haken-Icon markiert.
    \item Ausgewählte Items werden als Chips oberhalb der Liste angezeigt, mit Möglichkeit zum Entfernen (×).
    \item Die Komponente ist optisch anpassbar und nutzt Tailwind-Klassen für modernes Design.
\end{itemize}

\textbf{Logik:}
\begin{itemize}
    \item Die Auswahl und das Entfernen von Items werden über die Props gesteuert.
    \item Die Suchfunktion filtert die angezeigten Optionen.
\end{itemize}

\noindent\textbf{Verwendung:} CustomMultiSelect eignet sich für Filter- und Auswahlfunktionen, bei denen mehrere Werte gleichzeitig gewählt werden können, z.B. zur Produktsuche oder Kategoriefilterung. Sie ist flexibel und einfach in verschiedene UI-Kontexte integrierbar.

\subsection{(Produkt-)Details}

\subsubsection{Field}
Die Komponente Field ist ein flexibler, klickbarer Button für React Native, der ein Icon und optional einen Text anzeigt.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{icon:} Das anzuzeigende Icon (React-Komponente).
    \item \textbf{text:} Optionaler Text, der neben dem Icon angezeigt wird.
    \item \textbf{iconColor:} Farbe des Icons (wird über das Icon selbst gesteuert).
    \item \textbf{backgroundColor:} Hintergrundfarbe des Buttons.
    \item \textbf{onPress:} Optionaler Callback, der beim Klick ausgeführt wird.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Der Button ist abgerundet, horizontal ausgerichtet und zentriert.
    \item Das Icon steht links, der Text (falls vorhanden) rechts daneben.
    \item Der Hintergrund ist individuell anpassbar.
    \item Die Klick-Animation wird über activeOpacity gesteuert.
\end{itemize}

\noindent\textbf{Verwendung:} Field eignet sich für verschiedene Interaktionsmöglichkeiten, z.B. als Mengen-Auswahl, Aktions-Button oder für Eingabefelder mit Icon. Das Design ist flexibel und kann mit unterschiedlichen Icons, Farben und Texten verwendet werden.

\subsubsection{QuantityInput}
Die Komponente QuantityInput ist ein Eingabefeld für Mengenangaben, das Benutzern ermöglicht, eine Zahl durch Plus- und Minus-Buttons zu erhöhen oder zu verringern.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Props:}
\begin{itemize}
    \item \textbf{value:} Startwert der Menge (Standard: 1).
    \item \textbf{onChange:} Callback, der bei jeder Änderung der Menge ausgelöst wird.
    \item \textbf{min, max:} Minimale und maximale erlaubte Werte (Standard: 1 bis 99).
\end{itemize}

\textbf{Logik:}
\begin{itemize}
    \item Die aktuelle Menge wird im State quantity gehalten.
    \item Beim Klick auf den Minus-Button wird die Menge um 1 verringert, solange sie über dem Minimum liegt.
    \item Beim Klick auf den Plus-Button wird die Menge um 1 erhöht, solange sie unter dem Maximum liegt.
    \item Jede Änderung ruft den onChange-Callback mit dem neuen Wert auf.
\end{itemize}

\textbf{Darstellung:}
\begin{itemize}
    \item Die Komponente besteht aus einer horizontalen Reihe mit Minus-Button, Mengenanzeige und Plus-Button.
    \item Die Buttons sind rund und heben sich optisch ab, die aktuelle Menge wird mittig angezeigt.
\end{itemize}

\noindent\textbf{Verwendung:} QuantityInput eignet sich für Produktdetailseiten oder Warenkörbe, wo Nutzer die gewünschte Menge eines Artikels einstellen können. Sie ist intuitiv bedienbar und flexibel einsetzbar.

\subsubsection{ProductLoadingSkeleton}
Die Komponente ProductLoadingSkeleton zeigt ein Ladeplatzhalter-Layout für Produktdetailseiten an, während die echten Daten geladen werden.

\noindent\textbf{Aufbau und Funktionsweise:}

\textbf{Darstellung:}
\begin{itemize}
    \item Die Komponente besteht aus mehreren grauen, animierten Rechtecken ("Skeletons"), die die Struktur der später angezeigten Produktinformationen nachahmen.
    \item Es gibt Platzhalter für das Produktbild, Titel, Varianten, Angebote und einen Button.
    \item Die Platzhalter sind mit der Klasse animate-pulse versehen, um eine pulsierende Ladeanimation darzustellen.
\end{itemize}

\textbf{Layout:}
\begin{itemize}
    \item Die Elemente sind optisch so angeordnet, wie die echten Produktdetails später erscheinen würden.
    \item Das Layout ist responsiv und zentriert.
\end{itemize}

\noindent\textbf{Verwendung:} ProductLoadingSkeleton wird angezeigt, wenn Produktdaten noch nicht geladen sind, um dem Nutzer ein visuelles Feedback zu geben und die Wartezeit angenehmer zu gestalten. Sie verbessert die User Experience durch ein modernes Lade-Design.

\vspace{1em}
\noindent
Dieses Kapitel liefert einen Rahmen für die Dokumentation der Benutzeroberfläche und kann im Laufe des Projekts kontinuierlich mit Inhalten, Screenshots und technischen Details erweitert werden.


\end{document}
